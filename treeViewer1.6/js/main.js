// ====================================
// Configuration et initialisation
// ====================================
import { parseGEDCOM } from './gedcomParser.js';
import { drawTree } from './treeRenderer.js';
import { findYoungestPerson, findPersonByName } from './utils.js';
import { buildAncestorTree, buildDescendantTree, buildCombinedTree } from './treeOperations.js';
import { initNetworkListeners, startAncestorAnimation, initializeAnimationMapPosition, 
    toggleAnimationPause, resetAnimationState  } from './treeAnimation.js';
import { geocodeLocation, loadGeolocalisationFile } from './geoLocalisation.js';
import { nameCloudState } from './nameCloud.js';
import { initializeCustomSelectors, replaceRootPersonSelector, enforceTextTruncation, 
    applyTextDefinitions, updateGenerationSelectorValue, updateTreeModeSelector,
    setupSearchFieldModal } from './mainUI.js'; 
import { createEnhancedSettingsModal } from './treeSettingsModal.js';
import { hideLoginBackground } from './eventHandlers.js';
import { showHamburgerMenu, initializeHamburgerOnce } from './hamburgerMenu.js';
import { initTilePreloading } from './mapTilesPreloader.js';
import { initResourcePreloading, fetchResourceWithCache } from './resourcePreloader.js';
import { createAudioElement } from './audioPlayer.js';

import { cleanupExportControls } from './exportSettings.js';

import { setMaxGenerationsInit } from './treeWheelRenderer.js';
import { enableFortuneMode, disableFortuneModeWithLever } from './treeWheelAnimation.js'
import { debugLog } from './debugLogUtils.js'
import { createDataForHeatMap } from './geoHeatMapDataProcessor.js';
import { createImprovedHeatmap } from './geoHeatMapUI.js';

import { getTranslation } from './nameCloudUI.js';


import { 
    displayPersonDetails, 
    closePersonDetails,
    setAsRootPerson,
    closeModal
} from './modalWindow.js';
import {
    initializeEventHandlers,
    updatePrenoms,
    updateLettersInNames,
    updateGenerations,
    zoomIn,
    zoomOut,
    resetView,
    resetZoom,
    searchTree
} from './eventHandlers.js';

let stopMonitoring = null;


// Enregistrement du Service Worker pour permettre le mode hors ligne
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./service-worker.js')
      .then(registration => {
        console.log('‚úÖ Service Worker enregistr√© avec succ√®s:', registration.scope);
        
        // V√©rifier si une mise √† jour est disponible
        registration.onupdatefound = () => {
          const installingWorker = registration.installing;
          installingWorker.onstatechange = () => {
            if (installingWorker.state === 'installed') {
              if (navigator.serviceWorker.controller) {
                console.log('Nouveau Service Worker install√©, sera activ√© au prochain chargement');
              } else {
                console.log('Service Worker install√© pour la premi√®re fois');
              }
            }
          };
        };
      })
      .catch(error => {
        console.error('√âchec de l\'enregistrement du Service Worker:', error);
      });
  }

  
// for tracking with google Analytics
export function trackPageView(pagePath) {
    if (window.gtag) {
        console.log(`üìä Suivi de la vue de page pour google Analytics: ${pagePath}`);
        gtag('event', 'page_view', {
            page_location: window.location.href,
            page_title: pagePath
        });
    }
}




export const state = {
    gedcomData: null,
    rootPersonId: null,
    rootPerson: null,
    currentTree: null,
    nombre_prenoms: 2,
    nombre_lettersInPrenoms: 20,
    nombre_lettersInNames: 15,
    nombre_generation: 4,
    boxWidth: 150,
    boxHeight: 50,
    treeMode: 'ancestors', // ou 'descendants' ou 'both'
    treeModeReal: 'ancestors', // ou 'descendants' ou 'both'
    treeModeReal_backup: 'ancestors', // ou 'descendants' ou 'both'    
    lastHorizontalPosition: 0,
    lastVerticalPosition: 0,
    isSpeechEnabled: true,
    isSpeechEnabled2: true,
    isVoiceSelected: false,
    isAnimationPaused: false,
    isAnimationLaunched: false,
    isAnimationMapInitialized: false,
    targetAncestorId: "@I739@",
    targetCousinId: null,
    animationTargetAncestorId: "@I739@",
    animationRootPersonId: '@I1@',
    isTouchDevice: false,
    isMobile: false,
    isIOS: false,
    initialTreeDisplay: true,
    isHamburgerMenuInitialized: false,
    menuHamburgerInitialized: false,
    backgroundEnabled: true,
    previousWindowInnerWidth: 0,
    previousWindowInnerHeight: 0,
    lastWindowInnerWidth: 0,
    lastWindowInnerHeight: 0,
    screenResizeHasOccured: false,
    previousWindowInnerWidthInMap: 0,
    previousWindowInnerHeightInMap: 0,
    prevPrevWindowInnerWidthInMap: 0,
    prevPrevWindowInnerHeightInMap: 0,
    treeOwner: 1,
    isOnLine: false,
    isDebugLog: false,
    isRadarEnabled: false,
    radarStyle: 0,
    isWordCloudEnabled: false,
    WheelMode: {
        maxGenerations: 5,
        showSpouses: true,
        showSiblings: true,
        animationsEnabled: true
    },
    currentRadarAngle: 0,
    WheelZoom: null,
    cachedRadarPNG: null,
    isCacheValid: false,
    userHasInteracted: false,
    currentAnimationTimeouts: [],
    WheelConfig: {
        innerRadius: 80,
        generationWidth: 80,
        centerX: 0,
        centerY: 0,
        totalAngle: 2 * Math.PI, // 360¬∞ complet
        startAngle: -Math.PI / 2, // Commencer en haut
        maxGenerations: 4,
        limitMaxGenerations: 26 
    },
    lastWheelTransform: null,
    leverEnabled: true,
    isSpinning: false,
    speechSynthesisInitialized: false,
    isSpeechInGoodHealth: false,
    frenchVoice: null,
    currentNameCloudModal: null, // Pour stocker le modal du nuage de mots
    currentScale: 1.0,
    currentX: 0,
    currentY: 0,
    nodeStyle: 'classic', //'heraldic', //'hextech',//'bubble',//'galaxy', //'diamond', //'organic', //'silhouettes', //'heraldic', //'classic', 
    linkStyle: 'normal-dark', //'thick-light' //'veryThick-light', //, //, //'veryThick-colored', //'thin-dark', // 'thick-light' //, //,  //, //'normal-dark',

};

export { geocodeLocation };

window.toggleAnimationPause = toggleAnimationPause;


document.addEventListener('DOMContentLoaded', async () => {
    // Lancer le pr√©chargement des tuiles en t√¢che de fond
    initResourcePreloading();
    initTilePreloading();
});


function openGedcomModal() {
    document.getElementById('gedcom-modal').style.display = 'block';
}

function closeGedcomModal() {
    document.getElementById('gedcom-modal').style.display = 'none';
}

// ajoutez des options pour diff√©rents types de heatmap
export function createAncestorsHeatMap(type = 'all', rootPersonId = null) {
    import('./geoLocalisation.js').then(module => {
        module.createAncestorsHeatMap({
            type: type,
            rootPersonId: rootPersonId
        });k
    });
}

export function updateRadarButtonText() {
    const treeRadarToggleBtn = document.getElementById('radarBtn');
    const menu_nameTreeRadarBtn = document.getElementById('menu-nameTreeRadarBtn');
    if (treeRadarToggleBtn) {
        const span = treeRadarToggleBtn.querySelector('span');
        if (span) {
            span.textContent = state.isRadarEnabled ? 'üå≥' : 'üéØ';
        }
    }

    if (menu_nameTreeRadarBtn) {
        // Mettre √† jour le bouton du menu hamburger
        if (window.innerHeight < 800) {
            menu_nameTreeRadarBtn.querySelector('span').textContent = state.isRadarEnabled ? '  -  üåøüå≥' : '  -  üï∏Ô∏èüéØ';
        } else {
            menu_nameTreeRadarBtn.querySelector('span').textContent = state.isRadarEnabled ? 'üåøüå≥' : 'üï∏Ô∏èüéØ';
        }
    }

}

/**
 * Extrait toutes les personnes contenues dans un rootHierarchy (d3.hierarchy)

 * @returns {Array} Tableau de toutes les personnes (node.data)
 */
export function getPersonsFromTCurrenTree() {
    const persons = [];
    const rootHierarchy = d3.hierarchy(state.currentTree, node => node.children); 
    console.log('getPersonsFromTCurrenTree rootHierarchy', rootHierarchy);    
    function traverse(node) {
        if (!node) return;
        if (node.data) {
            persons.push(state.gedcomData.individuals[node.data.id]);
        }
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => traverse(child));
        }
    }
    traverse(rootHierarchy);
    return persons;
}

export async function displayHeatMap() {
   
    // Cr√©ation d'un indicateur de chargement
    const loadingIndicator = document.createElement('div');
    loadingIndicator.style.position = 'fixed';
    loadingIndicator.style.top = '50%';
    loadingIndicator.style.left = '50%';
    loadingIndicator.style.transform = 'translate(-50%, -50%)';
    loadingIndicator.style.backgroundColor = 'white';
    loadingIndicator.style.padding = '20px';
    loadingIndicator.style.borderRadius = '8px';
    loadingIndicator.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
    loadingIndicator.style.zIndex = '9999';
    // loadingIndicator.innerHTML = '<p>G√©n√©ration de la heatmap...</p><progress style="width: 100%;"></progress>';
    loadingIndicator.innerHTML = `<p>${getTranslation('mapGeneration')}</p><progress style="width: 100%;"></progress>`;

    document.body.appendChild(loadingIndicator);
    
    try {

        // R√©cup√©rer les param√®tres actuels de filtrage
        const currentConfig = {
            type: 'name', //state.treeMode,
            startDate: -6000, //parseInt(startDateInput.value),
            endDate: 3000, //parseInt(endDateInput.value),
            scope: 'all',
            rootPersonId:  null, //state.rootPersonId//scopeSelect.value !== 'all' ? finalRootPersonSelect.value : null
        };

        // const persons = getPersonsFromTCurrenTree();

        // G√©n√©rer les donn√©es pour la heatmap
        const heatmapData = await createDataForHeatMap(currentConfig, true);       

        // Supprimer l'indicateur de chargement
        document.body.removeChild(loadingIndicator);
        
        // Cr√©er la heatmap interactive
        if (heatmapData && heatmapData.length > 0) {
        // if (true) {
            // Cr√©er un titre pour la heatmap bas√© sur la configuration
            let heatmapTitle;

          
            // Utiliser la fonction pour cr√©er la heatmap
            if (document.getElementById('namecloud-heatmap-wrapper')) {
                createImprovedHeatmap(heatmapData, heatmapTitle, true, true);
            } else {
                createImprovedHeatmap(heatmapData, heatmapTitle, true, false, { top: window.innerHeight/2, left: 25, width: window.innerWidth-50, height: window.innerHeight/2-25 });
            }
            
        } else {
            // alert('Aucune donn√©e g√©ographique disponible pour les personnes s√©lectionn√©es.');
            // alert(getTranslation('noGeoData'));
        }
    } catch (error) {
        console.error('Erreur lors de la g√©n√©ration de la heatmap:', error);
        if (document.body.contains(loadingIndicator)) {
            document.body.removeChild(loadingIndicator);
        }
        // alert(`Erreur lors de la g√©n√©ration de la heatmap: ${error.message}`);
        // alert(`${getTranslation('errorHeatmap')}: ${error.message}`);
    }
}



export function toggleTreeRadar() {
    // Basculer l'√©tat du tree/radar
    state.isRadarEnabled = !state.isRadarEnabled;  
    updateRadarButtonText();  

    if (state.isRadarEnabled) {
        state.treeModeReal_backup = state.treeMode;        
        displayGenealogicTree(null, false, false,  false, 'WheelAncestors');

    } else {

        if ((state.treeModeReal_backup.includes('ncestors')) && !(state.treeMode.includes('ncestors'))) {
            state.treeMode = 'ancestors';
            state.treeModeReal = 'ancestors';
            state.treeModeReal_backup = 'ancestors';

        } else if ((state.treeModeReal_backup.includes('escendants')) && !(state.treeMode.includes('escendants'))) {
            state.treeMode = 'descendants';
            state.treeModeReal = 'descendants';
            state.treeModeReal_backup = 'descendants';
        } else {
            state.treeMode = state.treeModeReal_backup;
            state.treeModeReal = state.treeModeReal_backup;  
        }      
        displayGenealogicTree(null, true, false);
    }
}

// Fonction pour basculer le son
export function toggleSpeech() {
    const speechToggleBtn = document.getElementById('speechToggleBtn');
    
    // Basculer l'√©tat du son
    state.isSpeechEnabled = !state.isSpeechEnabled;




    
    // Mettre √† jour le bouton
    speechToggleBtn.querySelector('span').textContent = state.isSpeechEnabled ? 'üîä' : 'üîá';


}

// Fonction pour desactiver compl√®tement le son dans l'animation
export function toggleSpeech2() {
    const menu_speechToggleBtn = document.getElementById('menu-speechToggleBtn');
    
    // Basculer l'√©tat du son
    state.isSpeechEnabled2 = !state.isSpeechEnabled2;




    
    // Mettre √† jour le bouton
    menu_speechToggleBtn.querySelector('span').textContent = state.isSpeechEnabled2 ? 'üó£Ô∏è' : 'üîá';
    // Appliquer le style uniquement pour l'emoji üó£Ô∏è
    if (menu_speechToggleBtn.querySelector('span').textContent === 'üó£Ô∏è') {
        menu_speechToggleBtn.querySelector('span').style.filter = 'brightness(2) contrast(0.7) saturate(2)';
    } else {
        menu_speechToggleBtn.querySelector('span').style.filter = 'none'; // R√©initialiser le filtre pour üîá
    }



}

// Pour arr√™ter le monitoring
function stopBackgroundMonitoring() {
    if (window._monitoringStopFunction) {
      console.log("Arr√™t du monitoring du fond d'√©cran");
      const stats = window._monitoringStopFunction();
      console.log("Statistiques finales:", stats);
      window._monitoringStopFunction = null;
      return stats;
    } else {
      console.log("Pas de monitoring actif √† arr√™ter");
      return null;
    }
  }
  
// Pour red√©marrer le monitoring si n√©cessaire
function restartBackgroundMonitoring() {
// D'abord arr√™ter s'il est en cours
if (window._monitoringStopFunction) {
    stopBackgroundMonitoring();
}

// Puis red√©marrer avec la fonction originale
if (window._originalSetupElegantBackground) {
    console.log("Red√©marrage du monitoring du fond d'√©cran");
    import('./performanceMonitor.js').then(module => {
    window._monitoringStopFunction = module.monitorFunction(
        window, 
        '_originalSetupElegantBackground', 
        1000
    );
    });
} else {
    console.log("Impossible de red√©marrer, fonction originale non trouv√©e");
}
}

export function toggleFullScreen() {
    if (!document.fullscreenElement) {
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
        } else if (document.documentElement.mozRequestFullScreen) { // Firefox
            document.documentElement.mozRequestFullScreen();
        } else if (document.documentElement.webkitRequestFullscreen) { // Chrome, Safari and Opera
            document.documentElement.webkitRequestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) { // IE/Edge
            document.documentElement.msRequestFullscreen();
        }
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

function initialize() {   
     // Initialiser le s√©lecteur de g√©n√©rations standard d'abord
    // (n√©cessaire pour sa cr√©ation avant de le remplacer)
    initializeGenerationSelect();
    
    // Initialiser les gestionnaires d'√©v√©nements
    initializeEventHandlers();

    // üéØ : Initialisation iOS tr√®s t√¥t
    if (window.initializeIOSInstallation) {
        initializeIOSInstallation();
    }
    
    // Initialiser les s√©lecteurs personnalis√©s (remplace les s√©lecteurs standards)
    initializeCustomSelectors();

    // Appliquer les d√©finitions de texte
    applyTextDefinitions();





    // Ajouter l'√©v√©nement pour soumettre le formulaire avec Enter
    const passwordInput = document.getElementById('password');
    if (passwordInput) {
        console.log("Password input trouv√©, ajout de l'√©couteur d'√©v√©nement pour Enter");
        passwordInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                console.log("Touche Enter d√©tect√©e");
                event.preventDefault();
                loadData();
            }
        });
    } else {
        console.warn("√âl√©ment 'password' non trouv√© lors de l'initialisation");
    }


    setupSearchFieldModal();

    

}

/**
 * Initialise le s√©lecteur de g√©n√©rations
 */
function initializeGenerationSelect() {
    const select = document.getElementById('generations');
    for (let i = 2; i <= 101; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.text = i;
        if (i === 6) option.selected = true;
        select.appendChild(option);
    }
}


export let audio;
export let audioUnlocked = false;

/**
 * Charge les donn√©es GEDCOM et configure l'affichage de l'arbre
 */
export async function loadData() {


    trackPageView('AccueilTreeViewer');

    audio = await createAudioElement();
    audio.preload = 'auto';
    audio.volume = 1;

    state.treeMode = 'ancestors';
    state.treeModeReal = 'ancestors';


    // üí° D√©bloque l'audio √† ce moment-l√† pour IOS
    // Pour le cas IOS qui bloque la musique si la musique n'est pas d√©clench√©e par un clic
    // or en mode d√©mo la musique est lanc√©e √† la fin de l'animation , loin apr√®s le clic
    // dans ce cas il faut faire un pr√©-init de la musique. L eprobl√®me c'est qu'il faut d√©j√† connaitre quel mp3 il faut jouer. 
    // Il faudra sans doute d√©placer cet init juste apr√®s le clic du mode d√©mo qui d√©finit quelle musique doit √™tre jou√©e
    if (isIOSDevice() && !audioUnlocked) {
        audio.play().then(() => {
            audio.pause();
            audio.currentTime = 0;
            audioUnlocked = true;
            console.log("üîì Audio d√©bloqu√© !");
        }).catch(e => {
            console.warn("üõë iOS a bloqu√© l‚Äôaudio :", e);
        });
    } else {
        audioUnlocked = true;
    }
    

    state.lastWindowInnerWidth = window.innerWidth;
    state.lastWindowInnerHeight = window.innerHeight;
    state.previousWindowInnerWidth = state.lastWindowInnerWidth;
    state.previousWindowInnerHeight = state.lastWindowInnerHeight;

    state.nombre_generation = 4;
    updateGenerationSelectorValue(state.nombre_generation);

    updateTreeModeSelector(state.treeMode);


    // Utilisation
    const device = detectDeviceType();
    // showToast("isMobile= " + device.isMobile + " , hasTouchScreen=" + device.hasTouchScreen + ", inputType=" + device.inputType + ", Width="+ device.viewportWidth + ", Height="+ device.viewportHeight, 2000);
    
    // console.log("üåê √âtat initial du r√©seau:", navigator.onLine);
    // initNetworkListeners();

    // Initialiser la position de la carte d'animation
    if (!state.isAnimationMapInitialized) {
        initializeAnimationMapPosition();
    }
    
    if (device.hasTouchScreen || device.inputType === 'tactile') state.isTouchDevice = true;
  
    const fileInput = document.getElementById('gedFile');
    const passwordInput = document.getElementById('password');
    // toggleFullScreen();

    // for mobile phone
    nameCloudState.mobilePhone = false;
    if (Math.min(window.innerWidth, window.innerHeight) < 400 ) nameCloudState.mobilePhone = 1;
    else if (Math.min(window.innerWidth, window.innerHeight) < 600 ) nameCloudState.mobilePhone = 2;    
    
    try {
        let gedcomContent = await loadGedcomContent(fileInput, passwordInput);
        state.gedcomData = parseGEDCOM(gedcomContent);


        // IMPORTANT: Supprimer l'image de fond de la page d'accueil
        const loginBackground = document.querySelector('.login-background');
        if (loginBackground) {
            loginBackground.remove(); // Supprime compl√®tement l'√©l√©ment du DOM
        }
        // Nettoyer aussi tout autre conteneur de fond d'√©cran existant
        const existingBackgroundContainer = document.querySelector('.background-container');
        if (existingBackgroundContainer) {
            existingBackgroundContainer.remove();
        }

        document.getElementById('password-form').style.display = 'none';

        // Cacher le bouton param√®tres de la page d'accueil
        const settingsButton = document.getElementById('load-gedcom-button');
        if (settingsButton) {
            settingsButton.style.display = 'none';
        }

        document.getElementById('tree-container').style.display = 'block';

        // Si vous souhaitez remplacer l'image par un autre fond, vous pouvez initialiser
        // un nouveau conteneur ici, sinon, commentez ou supprimez cette ligne
        // initBackgroundContainer();

        // Chargement du fichier de g√©olocalisation
        await loadGeolocalisationFile();

        // Dispatch un √©v√©nement personnalis√©
        const event = new Event('gedcomLoaded');
        document.dispatchEvent(event);

        hideMap();



        let ancestor = null;
        let cousin = null;
       if ((state.treeOwner === 5 ) || (state.treeOwner === 6)) {
            // state.targetAncestorId = "@I1152@";
            ancestor = searchRootPersonId('charlem');
            cousin = null; 
            state.targetAncestorId = ancestor.id;
        } else if (state.treeOwner === 4 ) {
            // state.targetAncestorId = "@I1152@";
            ancestor = searchRootPersonId('guillaume sez');
            cousin = null; 
            state.targetAncestorId = ancestor.id;
        } else if (state.treeOwner === 3 ) {
            // state.targetAncestorId = "@I1152@";
            ancestor = searchRootPersonId('hugues cap');
            cousin = null; 
            state.targetAncestorId = ancestor.id;
        } else if (state.treeOwner === 2 ) {
            // state.targetAncestorId = "@I1152@";
            ancestor = searchRootPersonId('guillaume ducl');
            cousin = null; 
            state.targetAncestorId = ancestor.id;
        } else if (state.treeOwner === 1 ){              
            // state.targetAncestorId = "@I739@" 
            ancestor = searchRootPersonId('alain ii goyon de matignon');  
            cousin = null; 
            state.targetAncestorId = ancestor.id;
        } else {
            ancestor = searchRootPersonId('alain ii goyon de matignon', false);  
            if (ancestor != null) {
                state.treeOwner = 1;
                state.targetAncestorId = ancestor.id;
            } 
            ancestor = searchRootPersonId('guillaume ducl', false);  
            if (ancestor != null) {
                state.treeOwner = 2;
                state.targetAncestorId = ancestor.id;
            }     

        }


        state.isRadarEnabled = false;


        updateRadarButtonText();

        state.initialTreeDisplay = true;
        console.log('\n\n\n\n ###################   CALL displayGenealogicTree in loadData ################# ')

        displayGenealogicTree(null, true, true);  // Appel avec isInit = true

        // Maintenant que l'arbre est affich√©, remplacer le s√©lecteur de personnes racines
        setTimeout(() => {
            replaceRootPersonSelector();
        }, 500); // Petit d√©lai pour s'assurer que tout est pr√™t
        
        hideLoginBackground();
            
        initializeHamburgerOnce();
        showHamburgerMenu();


        toggleFullScreen();
        
        
    } catch (error) {
        console.error('Erreur compl√®te:', error);
        alert(error.message);
    }
}

// Pour √™tre certain que le fond est bien supprim√©, on peut aussi ajouter une r√®gle CSS
// Vous pouvez ajouter ceci √† votre fichier CSS ou l'injecter dynamiquement
function injectCustomStyle() {
    const style = document.createElement('style');
    style.textContent = `
        .tree-container-active .login-background,
        .tree-container-active .background-container {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
        }
        
        /* Pour s'assurer que le fond est blanc ou transparent */
        body.tree-view {
            background: white !important;
        }
    `;
    document.head.appendChild(style);
    
    // Ajouter la classe √† body quand l'arbre est affich√©
    document.addEventListener('gedcomLoaded', function() {
        document.body.classList.add('tree-view');
        document.getElementById('tree-container').classList.add('tree-container-active');
    });
}

// Appelez cette fonction au chargement de la page
window.addEventListener('load', injectCustomStyle);


/**
 * Charge le contenu du fichier GEDCOM
 * @private
 */
async function loadGedcomContent(fileInput, passwordInput) {
    if ((!passwordInput.value) && (!fileInput.files[0])) {
        if (window.CURRENT_LANGUAGE === 'fr') {
            throw new Error('Veuillez s√©lectionner un fichier ou entrer un mot de passe');
        } else if (window.CURRENT_LANGUAGE === 'en') {
            throw new Error('Please select a file or enter a password');
        } else if (window.CURRENT_LANGUAGE === 'es') {
            throw new Error('Por favor, seleccione un archivo o ingrese una contrase√±a');
        } else if (window.CURRENT_LANGUAGE === 'hu') {
            throw new Error('K√©rj√ºk, v√°lasszon ki egy f√°jlt vagy adjon meg egy jelsz√≥t');
        }
    }

    if (passwordInput.value) {
        try {
            // Essayer d'abord avec arbre.enc
            const content = await loadEncryptedContent(passwordInput.value, 'arbre.enc');
            // Si succ√®s avec arbre.enc, d√©finir treeOwner = 1
            state.treeOwner = 1;
            console.log("Fichier arbre.enc ouvert avec succ√®s. Owner: 1");
            return content;
        } catch (error) {
            // Si le mot de passe est incorrect pour arbre.enc, essayer avec arbreX.enc
            if (error.message === 'Mot de passe incorrect') {
                console.log("Tentative d'ouverture du fichier arbreX.enc...");
                try {
                    const content = await loadEncryptedContent(passwordInput.value, 'arbreX.enc');
                    // Si succ√®s avec arbreX.enc, d√©finir treeOwner = 2
                    state.treeOwner = 2;
                    console.log("Fichier arbreX.enc ouvert avec succ√®s. Owner: 2");
                    return content;
                } catch (secondError) {
                    // Si le mot de passe est incorrect pour arbre.enc, essayer avec arbreB.enc
                    if (secondError.message === 'Mot de passe incorrect') {
                        console.log("Tentative d'ouverture du fichier arbreB.enc...");
                        try {
                            const content = await loadEncryptedContent(passwordInput.value, 'arbreB.enc');
                            // Si succ√®s avec arbreB.enc, d√©finir treeOwner = 3
                            state.treeOwner = 3;
                            console.log("Fichier arbreB.enc ouvert avec succ√®s. Owner: 3");
                            return content;
                        } catch (thirdError) {

                            if (thirdError.message === 'Mot de passe incorrect') {
                                console.log("Tentative d'ouverture du fichier arbreC.enc...");
                                try {
                                    const content = await loadEncryptedContent(passwordInput.value, 'arbreC.enc');
                                    // Si succ√®s avec arbreC.enc, d√©finir treeOwner = 4
                                    state.treeOwner = 4;
                                    console.log("Fichier arbreC.enc ouvert avec succ√®s. Owner: 4");
                                    return content;
                                } catch (fourthError) {

                                    if (fourthError.message === 'Mot de passe incorrect') {
                                        console.log("Tentative d'ouverture du fichier arbreG.enc...");
                                        try {
                                            const content = await loadEncryptedContent(passwordInput.value, 'arbreG.enc');
                                            // Si succ√®s avec arbreG.enc, d√©finir treeOwner = 5
                                            state.treeOwner = 5;
                                            console.log("Fichier arbreG.enc ouvert avec succ√®s. Owner: 5");
                                            return content;
                                        } catch (fifthError) {


                                            if (fourthError.message === 'Mot de passe incorrect') {
                                                console.log("Tentative d'ouverture du fichier arbreLE.enc...");
                                                try {
                                                    const content = await loadEncryptedContent(passwordInput.value, 'arbreLE.enc');
                                                    // Si succ√®s avec arbreLE.enc, d√©finir treeOwner = 6
                                                    state.treeOwner = 6;
                                                    console.log("Fichier arbreG.enc ouvert avec succ√®s. Owner: 6");
                                                    return content;
                                                } catch (fifthError) {
                                                    // Si le mot de passe est √©galement incorrect pour arbreX.enc
                                                    if (window.CURRENT_LANGUAGE === 'fr') {
                                                        throw new Error('Mot de passe incorrect pour les deux fichiers');
                                                    } else if (window.CURRENT_LANGUAGE === 'en') {
                                                        throw new Error('Incorrect password for both files');
                                                    } else if (window.CURRENT_LANGUAGE === 'es') {
                                                        throw new Error('Contrase√±a incorrecta para ambos archivos');
                                                    } else if (window.CURRENT_LANGUAGE === 'hu') {
                                                        throw new Error('Helytelen jelsz√≥ mindk√©t f√°jlhoz');
                                                    }
                                                }
                                            }
                                        }
                                    }
                                            
                                }
                            }
                        }
                    }
                }
            } else {
                // Si c'est une autre erreur (comme un probl√®me de r√©seau), la propager
                throw error;
            }
        }
    } else {
        // Pour un fichier t√©l√©charg√©, d√©finir treeOwner = 0 (ou autre valeur par d√©faut)
        state.treeOwner = 0;
        console.log("Fichier GEDCOM personnalis√© charg√©. Owner: 0");
        return await loadFileContent(fileInput.files[0]);
    }
}


/**
 * Charge le contenu crypt√© avec logs am√©lior√©s
 * @private
 */

async function loadEncryptedContent(password, filename) {
    debugLog(`Tentative de chargement: ${filename}`, 'info');
    debugLog(`Mode: ${state.isOnLine ? 'Connect√©' : 'Non connect√©'}`, state.isOnLine ? 'success' : 'warning');
    
    // V√©rifier les biblioth√®ques essentielles avant de continuer
    try {
        if (typeof pako === 'undefined' || typeof pako.inflate !== 'function') {
            debugLog("‚ùå Biblioth√®que 'pako' non charg√©e!", 'error');
        } else {
            debugLog("‚úì Biblioth√®que 'pako' disponible", 'success');
        }
    } catch (e) {
        debugLog("‚ùå Erreur lors de la v√©rification de pako: " + e.message, 'error');
    }
    
    let response;
    
    try {
        // Utiliser fetchResourceWithCache au lieu de fetch ou cache.match
        debugLog(`Chargement via fetchResourceWithCache...`, 'info');
        response = await fetchResourceWithCache(filename);
        debugLog(`R√©ponse: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
    } catch (fetchError) {
        debugLog(`Erreur r√©seau: ${fetchError.message}`, 'error');
        throw fetchError;
    }
    
    if (!response || !response.ok) {
        debugLog(`Erreur HTTP: ${response ? response.status : 'Aucune r√©ponse'}`, 'error');
        throw new Error(`Erreur lors du chargement du fichier ${filename}: ${response ? response.statusText : 'Aucune r√©ponse'}`);
    }
    
    try {
        const encryptedData = await response.text();
        debugLog(`Donn√©es re√ßues: ${encryptedData.length} caract√®res`, 'info');
        
        try {
            debugLog("D√©codage base64...", 'info');
            const decoded = atob(encryptedData);
            debugLog(`D√©cod√©: ${decoded.length} bytes`, 'info');
            
            debugLog("D√©chiffrement...", 'info');
            const key = password.repeat(decoded.length);
            const decrypted = new Uint8Array(decoded.length);
            
            for(let i = 0; i < decoded.length; i++) {
                decrypted[i] = decoded.charCodeAt(i) ^ key.charCodeAt(i);
            }
            debugLog("D√©chiffrement termin√©", 'info');
            
            debugLog("Validation mot de passe...", 'info');
            await validatePassword(password, decrypted);
            debugLog("Mot de passe valide", 'info');
            
            debugLog("D√©compression...", 'info');
            const result = pako.inflate(decrypted.slice(8), {to: 'string'});
            
            debugLog(`Chargement r√©ussi: ${result.length} caract√®res`, 'success');
            return result;
        } catch (processError) {
            debugLog(`Erreur traitement: ${processError.message}`, 'error');
            
            if (processError.message && processError.message.includes('mot de passe')) {
                throw new Error('Mot de passe incorrect');
            } else {
                throw processError;
            }
        }
    } catch (error) {
        debugLog(`Erreur finale: ${error.message}`, 'error');
        throw error;
    }
}


/**
 * Valide le mot de passe
 * @private
 */
async function validatePassword(password, decrypted) {
    const expectedHash = decrypted.slice(0, 8);
    const encoder = new TextEncoder();
    const passwordData = encoder.encode(password);
    const hashBuffer = await crypto.subtle.digest('SHA-256', passwordData);
    const actualHash = new Uint8Array(hashBuffer).slice(0, 8);
    
    if (!actualHash.every((val, i) => val === expectedHash[i])) {
        throw new Error('Mot de passe incorrect');
    }
}

/**
 * Charge le contenu du fichier
 * @private
 */
async function loadFileContent(file) {
    return new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        fileReader.onload = () => resolve(fileReader.result);
        fileReader.onerror = reject;
        fileReader.readAsText(file);
    });
}

/**
 * Ajoute une personne √† l'historique des racines et met √† jour le s√©lecteur
 * @param {Object} person - La personne √† ajouter
 */
function addToRootHistory(person) {


    if (person.name === state.gedcomData.individuals[person.id].name) {
        console.log('-----------debug addToRootHistory OK', person.id, person.name, state.gedcomData.individuals[person.id].name);

        // Utiliser la fonction de mise √† jour du s√©lecteur personnalis√©
        // au lieu de manipuler directement le s√©lecteur standard
        import('./mainUI.js').then(module => {
            if (typeof module.updateRootPersonSelector === 'function') {
                module.updateRootPersonSelector(person);
            } else {
                console.warn("La fonction updateRootPersonSelector n'est pas disponible");
                // Comportement de secours en cas d'√©chec
                fallbackUpdateRootPersonSelector(person);
            }
        }).catch(error => {
            console.error("Erreur lors de l'import de mainUI.js:", error);
            // Comportement de secours en cas d'√©chec
            fallbackUpdateRootPersonSelector(person);
        });
    }
}

// Fonction de secours qui utilise le code original
function fallbackUpdateRootPersonSelector(person) {
    const rootPersonResults = document.getElementById('root-person-results');
    if (!rootPersonResults) return;
    
    // R√©cup√©rer l'historique des racines depuis le localStorage
    let rootHistory = JSON.parse(localStorage.getItem('rootPersonHistory') || '[]');
    
    // V√©rifier si cette personne est d√©j√† dans l'historique
    const existingIndex = rootHistory.findIndex(entry => entry.id === person.id);
    
    // Si la personne n'est pas dans l'historique, l'ajouter
    if (existingIndex === -1) {
        rootHistory.push({
            id: person.id,
            name: person.name.replace(/\//g, '').trim()
        });
        
        // Sauvegarder l'historique mis √† jour
        localStorage.setItem('rootPersonHistory', JSON.stringify(rootHistory));
    }

    // R√©initialiser le s√©lecteur
    rootPersonResults.innerHTML = '';
    
    // Remplir le s√©lecteur avec l'historique
    rootHistory.forEach(entry => {
        const option = document.createElement('option');
        option.value = entry.id;
        option.textContent = entry.name;
        rootPersonResults.appendChild(option);
    });

    // Ajouter l'option "clear history"
    const clearOption = document.createElement('option');
    clearOption.value = 'clear-history';
    clearOption.textContent = '--- Clear History ---';
    rootPersonResults.appendChild(clearOption);

    // // Ajouter l'option "demo1"
    // const demoOption = document.createElement('option');
    // demoOption.value = 'demo1';

    
    // // Ajouter l'option "demo2"
    // const demoOption2 = document.createElement('option');
    // demoOption2.value = 'demo2';
    // if (state.treeOwner ===2 ) { 
    //     demoOption.textContent = '--- d√©mo Clou du spectacle ---';
    //     demoOption2.textContent = '--- d√©mo Spain ---';
    // } else { 
    //     demoOption.textContent = '--d√©mo Costaud la Planche--';
    //     demoOption2.textContent = '--d√©mo on descend tous de lui--'; 
    // }


    // rootPersonResults.appendChild(demoOption);
    // rootPersonResults.appendChild(demoOption2);

    // S√©lectionner la personne courante
    rootPersonResults.value = person.id;
}

/**
 * G√®re le changement de s√©lection dans le s√©lecteur de personnes racines
 * @param {Event} event - L'√©v√©nement de changement
 */
export function handleRootPersonChange(event) {
    const selectedValue = event.target.value;
    
    if (selectedValue === 'clear-history') {
        // Vider l'historique
        localStorage.removeItem('rootPersonHistory');
        
        // Garder uniquement la racine actuelle dans l'historique
        const currentPerson = state.gedcomData.individuals[state.rootPersonId];
        let newHistory = [{
            id: currentPerson.id,
            name: currentPerson.name.replace(/\//g, '').trim()
        }];
        
        // Sauvegarder le nouvel historique
        localStorage.setItem('rootPersonHistory', JSON.stringify(newHistory));
        
        // Mettre √† jour le s√©lecteur avec seulement la racine actuelle
        addToRootHistory(currentPerson);
        
        return;
    }

    
    console.log('\ndebug handleRootPersonChange =', selectedValue)
    
    // if ((selectedValue === 'demo1') || (selectedValue === 'demo2')) {
    if (selectedValue.includes('demo')) {
        let ancestor;
        let cousin;
        if (state.treeOwner ===2 ) {
            if (selectedValue === 'demo1'){ 
                // state.targetAncestorId = "@I1152@";
                ancestor = searchRootPersonId('guillaume du');
            } //"@I74@" } // "@I739@" } //"@I6@" } //
            else { 
                // state.targetAncestorId = "@I2179@";
                ancestor = searchRootPersonId('alonso de ');
            }
            state.targetAncestorId = ancestor.id;
        } else if (state.treeOwner ===3 ) {
            if (selectedValue === 'demo1'){ 
                // state.targetAncestorId = "@I1152@";
                ancestor = searchRootPersonId('hugues c');
            } //"@I74@" } // "@I739@" } //"@I6@" } //
            else { 
                // state.targetAncestorId = "@I2179@";
                ancestor = searchRootPersonId('hugues c ');
            }
            state.targetAncestorId = ancestor.id;
        } else if (state.treeOwner ===4 ) {
            if (selectedValue === 'demo1'){ 
                // state.targetAncestorId = "@I1152@";
                ancestor = searchRootPersonId('guillaume sez');
                cousin = null;
            } else if (selectedValue === 'demo2'){  //'On descend tous de lui'
                // state.targetAncestorId = "@I1322@"
                ancestor = searchRootPersonId('richard por');
                cousin = null; 
            } else if (selectedValue === 'demo3'){  //'On descend tous de lui'
                // state.targetAncestorId = "@I1322@"
                ancestor = searchRootPersonId('catherine tymen (le)');
                cousin = null; 
            } else { 
                // state.targetAncestorId = "@I2179@";
                ancestor = searchRootPersonId('hugues c ');
            }
            state.targetAncestorId = ancestor.id;
        } else if (state.treeOwner ===5 || state.treeOwner ===6 ) {
            if (selectedValue === 'demo1'){ 
                // state.targetAncestorId = "@I1152@";
                ancestor = searchRootPersonId('charlemagne');
            } //"@I74@" } // "@I739@" } //"@I6@" } //
            else { 
                // state.targetAncestorId = "@I2179@";
                ancestor = searchRootPersonId('charlemagne');
            }
            state.targetAncestorId = ancestor.id;
        } else {
            if (selectedValue === 'demo1'){// 'Costaud la Planche'                   
                // state.targetAncestorId = "@I739@" 
                ancestor = searchRootPersonId('alain ii goyon de matignon');  
                // ancestor = searchRootPersonId('denis a');  
                // ancestor = searchRootPersonId('no√´l r');  

                cousin = null;       
            } else if (selectedValue === 'demo2'){  //'On descend tous de lui'
                // state.targetAncestorId = "@I1322@"
                ancestor = searchRootPersonId('charlemagne');
                cousin = null;  
            } else if (selectedValue === 'demo3'){ // 'comme un ouragan'
                // state.targetAncestorId = "@I1322@"
                ancestor = searchRootPersonId('bertrand gouyon');
                cousin = searchRootPersonId('stephanie marie elisabeth grimaldi');
            } else if (selectedValue === 'demo4'){  //'Espace'
                // state.targetAncestorId = "@I1322@"
                ancestor = searchRootPersonId('charles lebon');
                cousin = searchRootPersonId('thomas pesquet');
            } else if (selectedValue === 'demo5'){ // 'Arabe du futur'
                ancestor = searchRootPersonId('anthoine sicot');  
                cousin = searchRootPersonId('riad sattouf');          
            } else if (selectedValue === 'demo6'){ // 'Loup du Canada'
                ancestor = searchRootPersonId('andr√© du matz'); 
                cousin = searchRootPersonId('pierre garand');            
            } else if (selectedValue === 'demo7'){ // "c'est normal"
                ancestor = searchRootPersonId('jan demaure');
                cousin = searchRootPersonId('brigitte fontaine');             
            } else if (selectedValue === 'demo8'){ // "les bronz√©s"
                ancestor = searchRootPersonId('jean mathurin monvoisin');
                cousin = searchRootPersonId('dominique lavanant');             
            } else if (selectedValue === 'demo9'){ // 'avant JC'
                ancestor = searchRootPersonId('kamber de cambrie'); 
                cousin = null;            
            } else if (selectedValue === 'demo10'){ // 'Francs'
                ancestor = searchRootPersonId('pharabert des francs'); 
                cousin = null;            
            } else if (selectedValue === 'demo11'){ // 'Capet'
                ancestor = searchRootPersonId('hugues capet'); 
                cousin = null;           
            } else {
                ancestor = searchRootPersonId('charlemagne');
                cousin = null;
            }

            console.log('\n\n TARGET ANCESTOR = ', ancestor, ", COUSIN =" , cousin)
            state.targetAncestorId = ancestor.id;
            if (cousin != null) {
                state.targetCousinId = cousin.id;
            } else {
                state.targetCousinId = null;
            }   




        }


        // typeOptions = ['d√©mo1', 'd√©mo2', 'd√©mo3', 'd√©mo4', 'd√©mo5', 'd√©mo6', 'd√©mo7', 'd√©mo8', 'd√©mo9', 'd√©mo10'];
        // typeValues = ['demo1', 'demo2', 'demo3', 'demo4', 'demo5', 'demo6', 'demo7', 'demo8', 'demo9', 'demo10'];
        // typeOptionsExpanded = ['Costaud la Planche', 'On descend tous de lui', 'comme un ouragan', 'Espace', 'Arabe du futur', 'Loup du Canada', "c'est normal", 'avant JC', 'Francs', 'Capet'];
  



        
        // showMap();

        // R√©initialiser l'√©tat de l'animation avant de d√©marrer
        resetAnimationState();

        state.isAnimationLaunched = true;
        
        // Forcer 2 g√©n√©rations
        state.nombre_generation = 2;
        
        // Mettre √† jour le s√©lecteur si disponible
        const genSelect = document.getElementById('generations');
        if (genSelect) {
            genSelect.value = '2';
        }
        
        // Mettre √† jour l'√©tat de pause
        const animationPauseBtn = document.getElementById('animationPauseBtn');
        if (animationPauseBtn && animationPauseBtn.querySelector('span')) {
            animationPauseBtn.querySelector('span').textContent = '‚è∏Ô∏è';
        }
               
        
        // Redessiner l'arbre d'abord
        console.log('\n\n\n\n ###################   CALL displayGenealogicTree in handleRootPersonChange ################# ')

        displayGenealogicTree(null, true, false, true);
        
        // Nettoyer tous les conteneurs de fond d'√©cran existants
        const loginBackground = document.querySelector('.login-background');
        if (loginBackground) {
            loginBackground.remove();
        }
        const existingBackgroundContainer = document.querySelector('.background-container');
        if (existingBackgroundContainer) {
            existingBackgroundContainer.remove();
        }

        // D√©marrer l'animation apr√®s un court d√©lai
        setTimeout(() => {
            startAncestorAnimation();
        }, 500);
        
        // Mettre √† jour la valeur du s√©lecteur si possible
        const customSelector = document.querySelector('[data-text-key="rootPersonResults"]');
        if (customSelector && typeof customSelector.value !== 'undefined') {
            customSelector.value = state.rootPersonId;
        }
        

        enforceTextTruncation();

        return;
    }
}

/**
 * Affiche l'arbre g√©n√©alogique
 * @param {string} rootPersonId - ID optionnel de la personne racine
 * @param {boolean} isInit - Indique s'il s'agit de l'initialisation
 */
export function displayGenealogicTree(rootPersonId = null, isZoomRefresh = false, isInit = false, isInitDemo = false, mode = 'ancestors') {

    // R√©initialiser l'√©tat de l'animation avant de changer l'arbre
    resetAnimationState();

    if (state.isRadarEnabled) {
        disableFortuneModeWithLever();
        enableFortuneMode();
        state.currentRadarAngle = 0;
    } else {
        disableFortuneModeWithLever();
    }

    // Si pas de rootPersonId, on utilise soit l'existant soit le plus jeune
    // let person = rootPersonId ? state.gedcomData.individuals[rootPersonId] : state.rootPersonId  ? state.gedcomData.individuals[state.rootPersonId] : findYoungestPerson();


    let person; 
    if (state.treeOwner === 6) {
        person = rootPersonId ? state.gedcomData.individuals[rootPersonId] : state.rootPersonId ? state.gedcomData.individuals[state.rootPersonId] : (isInit ? findYoungestPerson() : findYoungestPerson());
    } else if (state.treeOwner === 5) {
        person = rootPersonId ? state.gedcomData.individuals[rootPersonId] : state.rootPersonId ? state.gedcomData.individuals[state.rootPersonId] : (isInit ? (findPersonByName("giovanna san") || findYoungestPerson()) : findYoungestPerson());
    } else if (state.treeOwner === 4) {
        person = rootPersonId ? state.gedcomData.individuals[rootPersonId] : state.rootPersonId ? state.gedcomData.individuals[state.rootPersonId] : (isInit ? (findPersonByName("Nadine C") || findYoungestPerson()) : findYoungestPerson());
    } else if (state.treeOwner === 3) {
        person = rootPersonId ? state.gedcomData.individuals[rootPersonId] : state.rootPersonId ? state.gedcomData.individuals[state.rootPersonId] : (isInit ? (findPersonByName("L√©on Mo") || findYoungestPerson()) : findYoungestPerson());
    } else {
        person = rootPersonId ? state.gedcomData.individuals[rootPersonId] : state.rootPersonId ? state.gedcomData.individuals[state.rootPersonId] : (isInit ? (findPersonByName("Emma A") || findYoungestPerson()) : findYoungestPerson());
    }
    // Important : toujours sauvegarder l'ID de la personne courante
    if (!state.isAnimationLaunched || (state.treeModeReal !== 'descendants' && state.treeModeReal !== 'directDescendants')) {
        state.rootPersonId = rootPersonId || person.id;
        state.rootPerson = state.gedcomData.individuals[state.rootPersonId];
    } 


    // Si c'est l'initialisation, configurer le s√©lecteur avec la premi√®re racine
    if (isInit) {
        const rootPersonResults = document.getElementById('root-person-results');
        rootPersonResults.innerHTML = '';
        addToRootHistory(person);
        rootPersonResults.style.display = 'block';
        rootPersonResults.style.backgroundColor = 'orange';
    } else {
        // Sinon, ajouter la nouvelle racine √† l'historique
        if (!state.isAnimationLaunched || (!state.treeModeReal==='descendants'&& !state.treeModeReal==='directDescendants'))  {
         addToRootHistory(person);
        }
    }


    updateBoxWidth();

    // Construire l'arbre selon le mode
    state.treeModeReal = state.treeMode;

    if (isInitDemo && state.targetCousinId != null  && state.treeModeReal === 'ancestors' ) {
        state.treeModeReal = 'directAncestors';
    }

    // Nettoyer les contr√¥les existants
    cleanupExportControls();

    if (state.isAnimationLaunched && (state.treeModeReal==='descendants'|| state.treeModeReal==='directDescendants'))  {
        const tempPerson = state.gedcomData.individuals[state.targetAncestorId];
        state.currentTree =  buildDescendantTree(tempPerson.id);
    }
    else {
        if (['WheelAncestors', 'WheelDescendants'].includes(mode)) {
            console.log('üåü Mode √©ventail d√©tect√©:', mode);
            // state.treeModeReal = mode;

            if (state.treeMode === 'directAncestors' || state.treeMode === 'ancestors' ) {
                state.treeMode = 'directAncestors';
                state.treeModeReal = 'directAncestors';
                state.currentTree = buildAncestorTree(person.id);
            } else {
                state.treeMode = 'directDescendants';
                state.treeModeReal = 'directDescendants';
                state.currentTree = buildDescendantTree(person.id);

            }
            updateTreeModeSelector(state.treeMode);
            state.treeModeReal_backup = state.treeModeReal;
            state.treeModeReal = mode;
            setMaxGenerationsInit(state.nombre_generation);
        } else {
            updateTreeModeSelector(state.treeMode);
            console.log('üåü Mode arbre classique d√©tect√©:', state.treeModeReal);
            // Pour les modes 'ancestors', 'directAncestors', 'both', 'directDescendants', 'descendants'
            state.currentTree = (state.treeMode === 'directDescendants' || state.treeMode === 'descendants' )
                ? buildDescendantTree(person.id)
                : (state.treeMode === 'directAncestors' || state.treeMode === 'ancestors' )
                ? buildAncestorTree(person.id)
                : (state.treeMode === 'both')
                ? buildCombinedTree(person.id) // Pour le mode 'both'
                : buildAncestorTree(person.id);
        }
    }


    updateGenerationSelectorValue(state.nombre_generation);


    // drawTree(isZoomRefresh);
    drawTree(isZoomRefresh, false); // with WheelAncestors

    // drawWheelTree(true, false);

    // Ne pas faire resetView() en mode both
    if (state.treeModeReal !== 'both') {
        resetView();    
    }

}

window.displayGenealogicTree = displayGenealogicTree; // Exposer la fonction pour l'utiliser dans d'autres modules

/**
 * Met √† jour la largeur des bo√Ætes en fonction du nombre de pr√©noms
 * @private
 */
function updateBoxWidth() {
    if (typeof state.nombre_prenoms === 'string') {
        state.nombre_prenoms = parseInt(state.nombre_prenoms, 10);
    }
    if (typeof state.nombre_lettersInNames === 'string') {
        state.nombre_lettersInNames = parseInt(state.nombre_lettersInNames, 10);
    }
    // state.boxWidth = state.nombre_prenoms === 1 ? 90 : state.nombre_prenoms === 2 ? 120 : state.nombre_prenoms === 3 ? 150 : 180;

    if (state.nombre_prenoms === 1) {
        state.boxWidth = 90;
        state.nombre_lettersInNames = 11;
        state.nombre_lettersInPrenoms = 13;
    }
    else if (state.nombre_prenoms === 2) {
        state.boxWidth = 120;
        state.nombre_lettersInNames = 15;
        state.nombre_lettersInPrenoms = 18;
    }
    else if (state.nombre_prenoms === 3) {
        state.boxWidth = 150;
        state.nombre_lettersInNames = 19;
        state.nombre_lettersInPrenoms = 23;
    }
    else if (state.nombre_prenoms === 4) {
        state.boxWidth = 180;
        state.nombre_lettersInNames = 24;
        state.nombre_lettersInPrenoms = 30;
    }
    // state.boxWidth = state.nombre_lettersInNames < 11 ? 90 : state.nombre_lettersInNames <= 15 ? 120 : state.nombre_lettersInNames <= 19 ? 140 : state.nombre_lettersInNames <= 13 ? 160 : 180;
}

/**
 * Met √† jour le mode d'affichage de l'arbre (ascendants/descendants)
 * et redessine l'arbre avec le nouveau mode
 * @param {string} mode - Le mode d'affichage ('ancestors' ou 'descendants')
 */
export function updateTreeMode(mode) {
    // R√©initialiser l'√©tat de l'animation avant de changer le mode
    resetAnimationState();

    if (state.isRadarEnabled) {
        // state.treeMode = 'directAncestors';
        // mode = 'directAncestors';
        state.treeMode = mode;
        displayGenealogicTree(null, false, false,  false, 'WheelAncestors');
    } else {
        state.treeMode = mode;
        displayGenealogicTree(null, true, false);
    }

    // state.treeMode = mode;
    console.log('\n\n\n\n ###################   CALL displayGenealogicTree in updateTreeMode ################# ')

    // displayGenealogicTree(null, true, false);

    // pour mettre √† jour la description
    const description = document.getElementById('treeModeDescription');
    if (description) {
        if (mode === 'directAncestors') {
            description.textContent = 'Ascendants directs';
        } else if (mode === 'ancestors') {
            description.textContent = 'Ascendants + fratrie';
        } else if (mode === 'directDescendants'){
            description.textContent = 'Descendants direct';
        } else if (mode === 'descendants') {
            description.textContent = 'Descendants + conjoints';
        } else {
            description.textContent = 'Ascendants + Descendants';
        }
    }


}

// Fonctions de gestion de la modal de param√®tres
// export function openSettingsModal() {
//     const settingsModal = document.getElementById('settings-modal');
//     settingsModal.style.display = 'block';

//     // Charger la valeur actuelle
//     const currentTargetId = localStorage.getItem('targetAncestorId') || '@I741@';
//     document.getElementById('targetAncestorId').value = currentTargetId;

//     initBackgroundSelector();

// }


export function openSettingsModal() {
    // Option 1: Utiliser directement la nouvelle modal
    createEnhancedSettingsModal();
}


export function closeSettingsModal() {
    const settingsModal = document.getElementById('settings-modal');
    settingsModal.style.display = 'none';
}

export function saveTargetAncestorId() {
    const targetId = document.getElementById('targetAncestorId').value.trim();
    
    if (targetId) {
        localStorage.setItem('targetAncestorId', targetId);
        
        // Utiliser la fonction de mise √† jour
        import('./treeAnimation.js').then(module => {
            module.setTargetAncestorId(targetId);
        });

        alert('ID de l\'anc√™tre enregistr√© avec succ√®s !');
        closeSettingsModal();
    } else {
        alert('Veuillez entrer un ID valide');
    }
}

// Fonction pour masquer la map
export function hideMap() {
    const mapContainer = document.getElementById('animation-map-container');
    if (mapContainer) {
        mapContainer.style.display = 'none';
    }
}

// Fonction pour afficher la map
// export function showMap() {
//     const mapContainer = document.getElementById('animation-map-container');
//     mapContainer.style.display = 'block';
// }







// Fonction pour afficher un message toast temporaire
export function showToast(message, duration = 2500) {
    const toast = document.getElementById('mobile-toast');
    if (toast) {
        toast.textContent = message;
        toast.style.display = 'block';

        // Masquer apr√®s le d√©lai sp√©cifi√©
        setTimeout(() => {
            toast.style.display = 'none';
        }, duration);
    }
}



// Objet pour stocker les compteurs d'actions
const actionCounters = {};
const max_count = 3;


// Ajouter les messages toast aux boutons et s√©lecteurs
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.controls-row-1 button, .controls-row-2 button, select, .controls-row-1 input, .controls-row-2 input').forEach(element => {
        element.addEventListener('change', function() {
            const message = this.getAttribute('data-action');
            if (message) {
                const key = this.getAttribute('data-text-key');
                if (!actionCounters[key]) {
                    actionCounters[key] = 0;
                }
                actionCounters[key]++;
                if (actionCounters[key] <= max_count) {
                    showToast(message);
                }
            }
        });

        // Pour les s√©lecteurs, utiliser l'√©v√©nement change
        if (element.tagName === 'SELECT') {
            element.addEventListener('change', function() {
                const selectedOption = this.options[this.selectedIndex];
                const message = selectedOption.getAttribute('data-action') || this.getAttribute('data-action');
                if (message) {
                    const key = this.getAttribute('data-text-key');
                    if (!actionCounters[key]) {
                        actionCounters[key] = 0;
                    }
                    actionCounters[key]++;
                    if (actionCounters[key] <= max_count) {
                        showToast(message);
                    }
                }
            });
        }

        // Pour les champs de saisie, utiliser l'√©v√©nement input
        if (element.tagName === 'INPUT') {
            element.addEventListener('input', function() {
                const message = this.getAttribute('data-action');
                if (message) {
                    const key = this.getAttribute('data-text-key');
                    if (!actionCounters[key]) {
                        actionCounters[key] = 0;
                    }
                    actionCounters[key]++;
                    if (actionCounters[key] <= max_count) {
                        showToast(message);
                    }
                }
            });
        }

        // Garder le clic pour tous
        element.addEventListener('click', function() {
            const message = this.getAttribute('data-action');
            if (message) {
                const key = this.getAttribute('data-text-key');
                if (!actionCounters[key]) {
                    actionCounters[key] = 0;
                }
                actionCounters[key]++;
                if (actionCounters[key] <= max_count) {
                    showToast(message);
                }
            }
        });
    });


    initNetworkListeners();
    console.log("üåê √âtat initial du r√©seau:", state.isOnLine, ",?:", navigator.onLine);
});



function detectInputType() {
  // V√©rifie si l'appareil utilise principalement une souris
  const prefersMouse = window.matchMedia('(pointer: fine)').matches;
  
  // V√©rifie si l'appareil utilise principalement un toucher
  const prefersTouch = window.matchMedia('(pointer: coarse)').matches;
  
  // V√©rifie si l'appareil n'a pas de dispositif de pointage principal
  const noPointer = window.matchMedia('(pointer: none)').matches;
  
  if (prefersMouse) return "souris";
  if (prefersTouch) return "tactile";
  if (noPointer) return "sans_pointeur";
  
  // Fallback pour les navigateurs qui ne supportent pas ces media queries
  return "inconnu";
}

// ==========  fonction de d√©tection iOS ==========
export function isIOSDevice() {
    let isIOS = /iPad|iPhone|iPod|Macintosh|Mac OS/.test(navigator.userAgent) || 
           (navigator.userAgent.includes('Mac') && 'ontouchend' in document) ||
           (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));
    state.isIOS = isIOS;
    // state.isIOS = true;
    debugLog(`‚ÑπÔ∏è  isIOS : ${state.isIOS}`, "info")
    return state.isIOS;
}


export function detectDeviceType() {
  const deviceInfo = {
    isMobile: false,
    hasTouchScreen: false,
    inputType: "inconnu",
    viewportWidth: window.innerWidth,
    viewportHeight: window.innerHeight
  };
  
  // D√©tection par user-agent
//   deviceInfo.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

  deviceInfo.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Macintosh|Mac OS/i.test(navigator.userAgent);
  
  // D√©tection de l'√©cran tactile
  deviceInfo.hasTouchScreen = ('ontouchstart' in window) || 
                              (navigator.maxTouchPoints > 0) || 
                              (navigator.msMaxTouchPoints > 0);
  
  state.isMobile = deviceInfo.isMobile;
  debugLog(`‚ÑπÔ∏è  isMobile : ${state.isMobile}`, "info")
  state.isIOS = isIOSDevice();

  // D√©tection du type d'entr√©e principal
  if (window.matchMedia) {
    if (window.matchMedia('(pointer: fine)').matches) {
      deviceInfo.inputType = "souris";
    } else if (window.matchMedia('(pointer: coarse)').matches) {
      deviceInfo.inputType = "tactile";
    }
  }
  
  
  
  // // Utilisation
  // if (hasTouchScreen()) {
  //   console.log("√âcran tactile d√©tect√©");
  // } else {
  //   console.log("Pas d'√©cran tactile d√©tect√©");
  // }

  
  
  // // Utilisation
  // console.log(`Type d'entr√©e principal: ${detectInputType()}`);


  
  return deviceInfo;
}



// Exposer la fonction et le compteur globalement
window.showToast = showToast;
window.actionCounters = actionCounters;
// window.displayGenealogicTree = displayGenealogicTree;



// Export des variables et fonctions n√©cessaires
export {
    openGedcomModal,
    closeGedcomModal,
    displayPersonDetails,
    closePersonDetails,
    setAsRootPerson,
    closeModal,
    updatePrenoms,
    updateLettersInNames,
    updateGenerations,
    zoomIn,
    zoomOut,
    resetZoom,
    searchTree
};



window.addEventListener('load', initialize);





//  fonction searchRootPerson pour utiliser findPersonsByName :
export function searchRootPersonId(searchStr, isAlert = true) {

    // searchStr = searchStr.value.toLowerCase();

    if (!searchStr) return;

    // Utiliser la nouvelle fonction findPersonsByName

    
    const matchedPerson = findPersonByName(searchStr);



    if (matchedPerson) {
        // Convertir les personnes trouv√©es au format d'options pour le s√©lecteur personnalis√©
        // const options = matchedPersons.map(person => ({
        //     value: person.id,
        //     label: person.name.replace(/\//g, '').trim()
        // }));

        console.log('\n\n DEBUG search persone for demo ***********',matchedPerson)
        return matchedPerson;
        

    } else if (isAlert) {
        alert('Aucune personne trouv√©e');
        return null;
    }
}


// Gestionnaire des param√®tres avec support multi-langues
// Fonction pour r√©initialiser les param√®tres
export function resetToDefaultSettings() {
    // Obtenir les textes traduits
    const getText = (key) => window.i18n ? window.i18n.getText(key) : key;
    
    // Message de confirmation multilingue
    const confirmMessage = `${getText('confirmResetSettings')}\n\n${getText('resetWillDo')}:\n‚Ä¢ ${getText('deletePrefs')}\n‚Ä¢ ${getText('resetLang')}\n‚Ä¢ ${getText('clearCustomSettings')}\n\n(${getText('cacheWillBeKept')})`;
    
    if (confirm(confirmMessage)) {
        try {
            // Sauvegarder la langue actuelle si on veut la conserver
            // const currentLang = localStorage.getItem('preferredLanguage');
            
            // Vider tout le localStorage
            localStorage.clear();
            
            // Optionnel : remettre la langue (d√©commentez si vous voulez garder la langue)
            // if (currentLang) {
            //     localStorage.setItem('preferredLanguage', currentLang);
            // }
            
            console.log('Param√®tres remis √† z√©ro');
            
            // Afficher un message de confirmation multilingue
            alert(`${getText('resetSuccess')}\n\n${getText('pageWillReload')}`);
            
            // Recharger la page pour appliquer les changements
            window.location.reload();
            
        } catch (error) {
            console.error('Erreur lors de la r√©initialisation:', error);
            alert(getText('resetError'));
        }
    }
}

// Exposer la fonction globalement
// window.resetToDefaultSettings = resetToDefaultSettings;

// Fonction pour initialiser les param√®tres au chargement
function initializeSettings() {
    console.log('[Settings Manager] Initialis√©');
}

// Initialiser au chargement du DOM
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSettings);
} else {
    initializeSettings();
}

// Export pour les modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { resetToDefaultSettings };
}




/**
 * Gestion des erreurs
 */
function showErrorMessage(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = message;
    
    // Ajouter des styles d'erreur
    errorDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #dc3545;
        color: white;
        padding: 15px 20px;
        border-radius: 5px;
        z-index: 10000;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    `;
    
    document.body.appendChild(errorDiv);
    
    // Supprimer apr√®s 5 secondes
    setTimeout(() => {
        errorDiv.remove();
    }, 5000);
}


/**
 * Configuration par d√©faut √† adapter selon vos besoins
 */
// export const WheelConfig = {
//     defaultMode: 'WheelAncestors',
//     maxGenerations: 5,
//     enableAnimations: true,
//     exportFormat: 'png',
//     exportQuality: 1.0
// };

// Exemple d'utilisation :
// displayPersonTree('PERSON_ID', 'WheelAncestors');
// switchTreeMode('WheelDescendants');
// exportToPDF();


function positionRadarButton() {
    const cloudButton = document.getElementById('cloudBtn');
    const radarButton = document.getElementById('radarBtn');
    
    if (cloudButton && radarButton) {
        const cloudRect = cloudButton.getBoundingClientRect();
        radarButton.style.position = 'fixed';
        radarButton.style.left = cloudRect.left + 'px';
        radarButton.style.top = (cloudRect.bottom + 5) + 'px';
        radarButton.style.zIndex = '1001';
    }
}

// Nouvelle fonction pour l'overlay
function createAndPositionRadarOverlay() {
    // Trouver les boutons
    const cloudButton = document.getElementById('cloudBtn');
    const radarButton = document.getElementById('radarBtn');
    
    // V√©rifier que les boutons existent
    if (!cloudButton || !radarButton) return;
    
    // R√©cup√©rer les dimensions du bouton cloud
    const cloudRect = cloudButton.getBoundingClientRect();
    
    // Cr√©er l'overlay s'il n'existe pas d√©j√†
    let overlay = document.getElementById('radarBtn-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'radarBtn-overlay';
        overlay.style.position = 'fixed';
        overlay.style.backgroundColor = 'transparent';
        overlay.style.zIndex = '1002'; // Un peu plus haut que le bouton
        overlay.style.cursor = 'pointer';
        
        // Quand on clique sur l'overlay, on d√©clenche le clic du bouton radar
        overlay.addEventListener('click', () => {
            radarButton.click();
        });
        
        // Ajouter l'overlay au body
        document.body.appendChild(overlay);
    }
    
    // Positionner l'overlay
    overlay.style.top = `${cloudRect.bottom + 5}px`;
    overlay.style.left = `${cloudRect.left}px`;
    overlay.style.width = `${radarButton.offsetWidth}px`;
    overlay.style.height = `${radarButton.offsetHeight}px`;
}

function createAndPositionHeatMapOverlay() {
    const heatMapBtn = document.getElementById('heatMapBtn');
    if (!heatMapBtn) return;

    let overlay = document.getElementById('heatMapBtn-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'heatMapBtn-overlay';
        overlay.style.position = 'fixed';
        overlay.style.backgroundColor = 'transparent';
        overlay.style.zIndex = '1002';
        overlay.style.cursor = 'pointer';
        overlay.addEventListener('click', () => {
            heatMapBtn.click();
        });
        document.body.appendChild(overlay);
    }

    const rect = heatMapBtn.getBoundingClientRect();
    overlay.style.top = `${rect.top - 10}px`;
    overlay.style.left = `${rect.left - 10}px`;
    overlay.style.width = `${rect.width + 20}px`;
    overlay.style.height = `${rect.height + 20}px`;
}

function positionHeatMapButton() {
    // const settingsBtn = document.getElementById('settingsBtn');
    const heatMapBtn = document.getElementById('heatMapBtn');
    
    if (settingsBtn && heatMapBtn) {
        const settingRect = settingsBtn.getBoundingClientRect();
        heatMapBtn.style.position = 'fixed';
        heatMapBtn.style.left = (settingRect.left - 1)+ 'px';
        heatMapBtn.style.top = (settingRect.bottom + 5) + 'px';
        heatMapBtn.style.zIndex = '1001';
    }
}

// Modifier vos √©couteurs existants
document.addEventListener('DOMContentLoaded', () => {
    positionRadarButton();
    positionHeatMapButton();
    createAndPositionRadarOverlay();
    createAndPositionHeatMapOverlay();
});

window.addEventListener('resize', () => {
    positionRadarButton();
    positionHeatMapButton();
    createAndPositionRadarOverlay();
    createAndPositionHeatMapOverlay();
});
