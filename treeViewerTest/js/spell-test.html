<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Saisie Vocale Lettre par Lettre (Pure)</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        #output { font-size: 2em; margin: 20px 0; min-height: 1.5em; border: 1px solid #ccc; padding: 10px; }
        button { padding: 10px 20px; font-size: 1.2em; cursor: pointer; }
        .recording { background-color: red; color: white; }
    </style>
</head>
<body>

    <h1>Saisie Vocale: √âpellation (Lettre par Lettre)</h1>
    <p>Dites une lettre, un chiffre, ou "terminer". **Faites une petite pause entre chaque √©l√©ment.**</p>
    
    <div id="output">...</div>
    <div id="status" style="color: blue;">Pr√™t √† d√©marrer l'√©pellation.</div>
    
    <button id="toggle-record">D√©marrer l'√âpellation</button>

    <script>
        const outputElement = document.getElementById('output');
        const statusElement = document.getElementById('status');
        const toggleButton = document.getElementById('toggle-record');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList;

        if (!SpeechRecognition) {
            statusElement.textContent = "API Speech Recognition non support√©e dans ce navigateur.";
        }

        let recognition = null;
        let isRecording = false;
        let cumulativeText = "";

        const alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
        const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const exitSpellingCommand = ['terminer', 'fin', 'fini'];

        function initializeRecognition() {
            if (recognition) return;

            recognition = new SpeechRecognition();
            recognition.lang = 'fr-FR'; 
            recognition.interimResults = false; // Important: on veut seulement les r√©sultats finaux
            recognition.continuous = false; // TR√àS important: force l'arr√™t apr√®s chaque mot/silence
            
            // Cr√©ation de la grammaire stricte
            const spellingWords = [...alphabet, ...digits, ...exitSpellingCommand].join(' | ');
            const spellingGrammarString = `#JSGF V1.0; grammar spelling; public <letter_or_digit> = ${spellingWords} ;`;
            const spellingGrammar = new SpeechGrammarList();
            spellingGrammar.addFromString(spellingGrammarString, 1);
            
            recognition.grammars = spellingGrammar;
            
            // --- GESTIONNAIRES D'√âV√âNEMENTS ---

            recognition.onstart = () => {
                toggleButton.classList.add('recording');
                toggleButton.textContent = "STOP √âcoute üî¥";
                statusElement.textContent = "üéôÔ∏è √âcoute... Dites une lettre/chiffre ou 'terminer'.";
            };

            recognition.onresult = (event) => {
                const transcriptSegment = event.results[event.results.length - 1][0].transcript.trim().toLowerCase();
                
                // On s'assure que c'est le r√©sultat final (normal car interimResults est false)
                if (event.results[event.results.length - 1].isFinal) {

                    if (exitSpellingCommand.includes(transcriptSegment)) {
                        statusElement.textContent = `‚úÖ √âpellation termin√©e. R√©sultat final : "${cumulativeText}"`;
                        isRecording = false; 
                        recognition.stop(); // Arr√™t volontaire
                        return;
                    }

                    // Logique pour s'assurer que seuls les caract√®res uniques sont ajout√©s
                    let addedChars = '';
                    let recognizedWords = transcriptSegment.split(/\s+/);

                    // On it√®re sur tous les "mots" reconnus (qui devraient √™tre des lettres)
                    recognizedWords.forEach(word => {
                         // On ne prend que le premier caract√®re du mot reconnu pour √©viter la fusion (ex: 'deux' -> 'd')
                        const char = word.charAt(0); 

                        if (alphabet.includes(char) || digits.includes(char)) {
                            cumulativeText += char;
                            addedChars += char;
                        } else {
                             // Si le mot est un mot non pr√©vu mais final (ex: "bonjour")
                            statusElement.textContent = `‚ö†Ô∏è Mot non valide d√©tect√© ("${word}"). Ignor√©. R√©essayez.`;
                        }
                    });

                    if (addedChars.length > 0) {
                        statusElement.textContent = `Ajout√©: "${addedChars.toUpperCase()}". Prochaine lettre?`;
                    }
                    
                    outputElement.textContent = cumulativeText.toUpperCase() || '...';
                }
            };

            recognition.onend = () => {
                toggleButton.classList.remove('recording');
                toggleButton.textContent = "D√©marrer l'√âpellation";
                
                if (isRecording) {
                    // Si on est encore en mode enregistrement, on red√©marre l'√©coute imm√©diatement
                    // C'est ce qui cr√©e le cycle lettre-par-lettre, forc√© par continuous=false.
                    try {
                        recognition.start();
                        statusElement.textContent = "üéôÔ∏è √âcoute relanc√©e. Dites la prochaine lettre.";
                    } catch(e) {
                         statusElement.textContent = `‚ùå Erreur au red√©marrage : ${e.message}`;
                         isRecording = false;
                    }
                } else {
                     statusElement.textContent = `Pr√™t √† d√©marrer l'√©pellation. R√©sultat: ${cumulativeText}`;
                }
            };
            
            recognition.onerror = (event) => {
                statusElement.textContent = `‚ùå Erreur: ${event.error}. Arr√™t de l'√©pellation.`;
                isRecording = false;
                toggleButton.classList.remove('recording');
                toggleButton.textContent = "D√©marrer l'√âpellation";
            }
        }

        toggleButton.addEventListener('click', () => {
            initializeRecognition();

            if (isRecording) {
                isRecording = false;
                recognition.stop(); // Arr√™te la boucle onend -> start
            } else {
                isRecording = true;
                cumulativeText = "";
                outputElement.textContent = '...';
                try {
                    recognition.start();
                } catch(e) {
                     statusElement.textContent = `‚ùå Erreur de d√©marrage: ${e.message}.`;
                     isRecording = false;
                }
            }
        });

        initializeRecognition(); 
    </script>
</body>
</html>