<!DOCTYPE html>
<html>
<head>
   <meta charset="UTF-8">
   <title>Arbre Généalogique</title>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
   <style>
       body { 
           margin: 0; 
           font-family: Arial;
           overflow: hidden;
       }
       #password-form {
           position: fixed;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           background: white;
           padding: 20px;
           border-radius: 5px;
           box-shadow: 0 0 10px rgba(0,0,0,0.2);
           z-index: 1000;
       }
       .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .controls select, 
        .controls input[type="number"] {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .controls label {
            margin-left: 5px;
        }
       .node {
           cursor: pointer;
       }
       .node rect {
           fill: #fff;
           stroke: steelblue;
           stroke-width: 1.5px;
       }
       .node text {
           font: 12px sans-serif;
       }
       #tree-svg {
           width: 100%;
           height: 100vh;
       }
       .tooltip {
           position: absolute;
           background: white;
           padding: 5px;
           border: 1px solid #ccc;
           border-radius: 5px;
           pointer-events: none;
           opacity: 0;
           transition: opacity 0.3s;
       }
       .person-box {
            fill: white;
            stroke: steelblue;
            cursor: pointer;
            transition: stroke 0.3s;
        }
        .person-box.sibling {
            stroke: #4CAF50;  /* Vert pour les fratries */
        }
        .person-box:hover {
            stroke: #333;
            stroke-width: 2px;
        }
        .selected {
            stroke: #ff4444;
            stroke-width: 2px;
        }
        .search-highlight {
            fill: #ffeb3b;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }
        .link.spouse {
           stroke-dasharray: 5,5;
        }
        .link.sibling-link {
            stroke: #4CAF50;  /* Vert pour les liens de fratrie */
        }
        .link.hidden {
            display: none;
        }

   </style>
</head>
<body>
   <div id="password-form">
       <input type="password" id="password" placeholder="Mot de passe">
       <button onclick="loadData()">Voir l'arbre</button>
   </div>
   <div id="tree-container" style="display:none">
        <div class="controls">
            <button onclick="zoomIn()">Zoom +</button>
            <button onclick="zoomOut()">Zoom -</button>
            <button onclick="resetZoom()">Reset</button>
            <input type="text" id="search" placeholder="Rechercher..." oninput="searchTree(this.value)">
            <label for="prenoms">prénoms</label>
            <input type="number" id="prenoms" value="2" min="1" max="4" onchange="updatePrenoms(this.value)">
            <label for="generations">    générations</label>
            <input type="number" id="generations" value="3" min="2" max="100" onchange="updateGenerations(this.value)">

        </div>

       <div class="tooltip"></div>
       <svg id="tree-svg"></svg>
   </div>
   <script>


// Configuration globale
const config = {
    boxWidth: 150,
    boxHeight: 40,
    duration: 750,
    nodeSpacing: 1.5,
    levelSpacing: 180
};

let currentTransform = { k: 1, x: 0, y: 0 };
let tooltip = d3.select(".tooltip");
let nombre_prenoms = 2;
let nombre_generation = 3;
let zoom;  // Déclarer zoom comme variable globale


// Définir toutes les fonctions de contrôle
function zoomIn() {
    const svg = d3.select("#tree-svg");
    const currentTransform = d3.zoomTransform(svg.node());
    svg.transition()
        .duration(750)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(currentTransform.x, currentTransform.y)
                .scale(currentTransform.k * 1.2)
        );
}

function zoomOut() {
    const svg = d3.select("#tree-svg");
    const currentTransform = d3.zoomTransform(svg.node());
    svg.transition()
        .duration(750)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(currentTransform.x, currentTransform.y)
                .scale(currentTransform.k / 1.2)
        );
}

function resetZoom() {
    const svg = d3.select("#tree-svg");
    const width = window.innerWidth;
    const height = window.innerHeight;
    svg.transition()
        .duration(750)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(width/4, height/2)
                .scale(0.8)
        );
}

function searchTree(str) {
    if (!str) {
        d3.selectAll('.person-box').classed('search-highlight', false);
        return;
    }
    
    const searchStr = str.toLowerCase();
    d3.selectAll('.node').each(function(d) {
        const name = d.data.name.toLowerCase();
        const matches = name.includes(searchStr);
        d3.select(this).select('.person-box')
            .classed('search-highlight', matches);
    });
}

function updatePrenoms(value) {
    nombre_prenoms = parseInt(value);
    loadData();
}

function updateGenerations(value) {
    nombre_generation = parseInt(value);
    loadData();
}


function parseGEDCOM(gedcomText) {
    const individuals = {};
    const families = {};
    const lines = gedcomText.split(/\r?\n/);
    let currentEntity = null;

    for (const line of lines) {
        const match = line.match(/^\s*(\d+)\s+(@\w+@)?\s*(\w+)?\s*(.*)?$/);
        if (!match) continue;

        const [_, level, id, tag, data] = match;

        if (level === "0" && id) {
            if (tag === "INDI") {
                individuals[id] = { 
                    id, 
                    name: "", 
                    birthDate: "", 
                    deathDate: "",
                    occupation: "",
                    families: [] 
                };
                currentEntity = individuals[id];
            } else if (tag === "FAM") {
                families[id] = { 
                    id, 
                    husband: null, 
                    wife: null, 
                    children: [],
                    marriageDate: ""
                };
                currentEntity = families[id];
            } else {
                currentEntity = null;
            }
        } else if (currentEntity && level === "1") {
            if (tag === "NAME" && currentEntity.name !== undefined) {
                currentEntity.name = data;  // Nouvelle version qui garde les slashes
            } else if (tag === "BIRT") {
                currentEntity._expectingBirthDate = true;
            } else if (tag === "DEAT") {
                currentEntity._expectingDeathDate = true;
            } else if (tag === "OCCU") {
                currentEntity.occupation = data;
            } else if (tag === "HUSB" && currentEntity.husband !== undefined) {
                currentEntity.husband = data;
            } else if (tag === "WIFE" && currentEntity.wife !== undefined) {
                currentEntity.wife = data;
            } else if (tag === "CHIL" && currentEntity.children !== undefined) {
                currentEntity.children.push(data);
            } else if (tag === "FAMC" || tag === "FAMS") {
                currentEntity.families.push(data);
            } else if (tag === "MARR") {
                currentEntity._expectingMarriageDate = true;
            }
        } else if (currentEntity && level === "2" && tag === "DATE") {
            if (currentEntity._expectingBirthDate) {
                currentEntity.birthDate = data;
                delete currentEntity._expectingBirthDate;
            } else if (currentEntity._expectingDeathDate) {
                currentEntity.deathDate = data;
                delete currentEntity._expectingDeathDate;
            } else if (currentEntity._expectingMarriageDate) {
                currentEntity.marriageDate = data;
                delete currentEntity._expectingMarriageDate;
            }
        }
    }

    return { individuals, families };
}

function findSiblings(personId, gedcomData, processed) {
    const siblings = [];
    const person = gedcomData.individuals[personId];
    
    // console.log(`[findSiblings] Recherche des frères/sœurs pour ${person.name}`);
    
    // Parcourir toutes les familles où la personne est un enfant
    person.families.forEach(famId => {
        const family = gedcomData.families[famId];
        if (family && family.children && family.children.includes(personId)) {
            // console.log(`[findSiblings] Famille trouvée ${famId} avec ${family.children.length} enfants`);
            // Ajouter tous les frères et sœurs non traités
            family.children
                .filter(id => id !== personId && !processed.has(id))
                .forEach(siblingId => {
                    const sibling = gedcomData.individuals[siblingId];
                    // console.log(`[findSiblings] Frère/Sœur trouvé(e): ${sibling.name} (non traité)`);
                    siblings.push(siblingId);
                });
        }
    });
    
    // console.log(`[findSiblings] Total frères/sœurs trouvés: ${siblings.length}`);
    return siblings;
}

function buildAncestorTree(personId, gedcomData, processed = new Set(), generation = 0, parentNode = null) {
    if (processed.has(personId) || generation >= nombre_generation) {
        // console.log(`[buildAncestorTree] Arrêt pour ${personId}: processed=${processed.has(personId)}, generation=${generation}`);
        return null;
    }

    const person = gedcomData.individuals[personId];
    // console.log(`[buildAncestorTree] Début traitement: ${person.name} (Generation: ${generation})`);

    // Créer le nœud pour la personne actuelle
    const node = {
        id: personId,
        name: person.name,
        generation: generation,
        children: []
    };

    // Trouver tous les frères et sœurs avant de marquer comme traité
    const siblings = findSiblings(personId, gedcomData, processed);
    // console.log(`[buildAncestorTree] ${siblings.length} frères/sœurs trouvés pour ${person.name}`);
    
    // Marquer la personne comme traitée après avoir trouvé les frères et sœurs
    processed.add(personId);
    // console.log(`[buildAncestorTree] ${person.name} marqué comme traité`);

    // Si nous avons un nœud parent et des frères et sœurs
    if (parentNode && generation < (nombre_generation-1)) {
        siblings.forEach(siblingId => {
            const siblingPerson = gedcomData.individuals[siblingId];
            // console.log(`[buildAncestorTree] Ajout frère/sœur ${siblingPerson.name} à génération ${generation}`);
            const sibling = {
                id: siblingId,
                name: siblingPerson.name,
                generation: generation,
                isSibling: true,
                children: []
            };
            // Ajouter le frère/sœur au même niveau que le nœud courant
            parentNode.children.push(sibling);
            processed.add(siblingId);
        });
    }

    // Traiter les familles pour les parents
    const familiesAsChild = person.families.filter(famId => {
        const family = gedcomData.families[famId];
        return family && family.children && family.children.includes(personId);
    });
    
    // console.log(`[buildAncestorTree] ${familiesAsChild.length} familles comme enfant pour ${person.name}`);

    // Traiter les parents après les frères et sœurs
    familiesAsChild.forEach(famId => {
        const family = gedcomData.families[famId];
        if (family) {
            if (family.husband && !processed.has(family.husband)) {
                const father = buildAncestorTree(family.husband, gedcomData, processed, generation + 1, node);
                if (father) node.children.push(father);
            }
            if (family.wife && !processed.has(family.wife)) {
                const mother = buildAncestorTree(family.wife, gedcomData, processed, generation + 1, node);
                if (mother) node.children.push(mother);
            }
        }
    });

    return node;
}


function formatLastWord(text) {
    const words = text.split(' ');
    const lastName = words[words.length - 1];
    const formattedLastName = lastName.charAt(0).toUpperCase() + lastName.slice(1).toLowerCase();
    words[words.length - 1] = formattedLastName;
    return words;
}


function displayPedigree(gedcomData) {
    const width = window.innerWidth;
    const height = window.innerHeight;
    var boxWidth = 150;
    if (nombre_prenoms === 1) {
        boxWidth = 90;
    }
    else if (nombre_prenoms === 2) {
        boxWidth = 120;
    }

    
    const boxHeight = 40;

    const youngest = Object.values(gedcomData.individuals)
        .filter(person => person.birthDate)
        .sort((a, b) => new Date(b.birthDate) - new Date(a.birthDate))[0];

    const treeData = buildAncestorTree(youngest.id, gedcomData);
    const root = d3.hierarchy(treeData);

    const tree = d3.tree()
        .nodeSize([boxHeight * 1.8, boxWidth * 1.3])
        .separation((a, b) => {
            if (a.data.isSibling || b.data.isSibling) {
                return 1.1;
            }
            if (a.depth === (nombre_generation-1) && b.depth === (nombre_generation-1) && a.parent !== b.parent) {
                return 0.7;
            }
            if (a.parent === b.parent) {
                const scale = Math.max(0.5, (nombre_generation - a.depth) / nombre_generation);
                return scale * (a.depth === b.depth ? 1.1 : 1.5);
            }
            return 1;
        });

    const svg = d3.select("#tree-svg")
        .attr("width", width)
        .attr("height", height);

    svg.selectAll("*").remove();

    const g = svg.append("g")
        .attr("transform", `translate(${boxWidth},${height/2})`);

    // Calculer les positions initiales
    const nodes = tree(root);

    // Ajuster la position verticale d'Emma
    const parents = root.children?.filter(n => !n.data.isSibling);
    if (parents && parents.length === 2) {
        // console.log("Position avant ajustement:", root.x);
        // console.log("Position parent 1:", parents[0].x);
        // console.log("Position parent 2:", parents[1].x);
        
        // Calculer le centre entre les deux parents
        const centerY = (parents[0].x + parents[1].x) / 2;
        
        // console.log("Nouvelle position calculée:", centerY);
        // Ajuster la position d'Emma
        root.x = centerY;
    }

    // Le reste du code pour dessiner les liens et les nœuds
    const link = g.selectAll(".link")
        .data(root.links())
        .join("path")
        .attr("class", d => {
            if (d.target.data.isSibling && d.source.data.generation < d.target.data.generation) {
                return "link hidden";
            }
            return (d.source.data.isSibling || d.target.data.isSibling) ? "link sibling-link" : "link";
        })
        .attr("d", d => {
            if (d.target.data.isSibling && d.source.data.generation < d.target.data.generation) {
                return "";
            }
            return `M${d.source.y},${d.source.x}
                    H${(d.source.y + d.target.y)/2}
                    V${d.target.x}
                    H${d.target.y}`;
        });

    const node = g.selectAll(".node")
        .data(root.descendants())
        .join("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.y},${d.x})`);

    node.append("rect")
        .attr("class", d => d.data.isSibling ? "person-box sibling" : "person-box")
        .attr("x", -boxWidth/2)
        .attr("y", -boxHeight/2)
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .attr("rx", 5);

    node.append("text")
    .attr("dy", "0.35em")
    .attr("text-anchor", "middle")
    .each(function(d) {
        const text = d3.select(this);
        
        const match = d.data.name.match(/(.*?)\/(.*?)\//);
        if (match) {
            const firstNames = match[1].trim();
            const lastName = match[2].trim().toUpperCase();
            
            // Traiter les prénoms avec tirets et limiter à 3
            const prenomWords = firstNames.split(' ')
                .reduce((acc, word) => {
                    // Si le mot contient un tiret
                    if (word.includes('-')) {
                        // Séparer sur le tiret et formater chaque partie
                        const parts = word.split('-')
                            .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase());
                        acc.push(...parts);
                    } else {
                        // Mot normal
                        acc.push(word.charAt(0).toUpperCase() + word.slice(1).toLowerCase());
                    }
                    return acc;
                }, [])
                .slice(0, nombre_prenoms);  // Limiter à 3 prénoms après avoir séparé les prénoms composés
            
            const formattedFirstNames = prenomWords.join(' ');
            const maxWidth = boxWidth - 10;

            text.text(null);
            
            // Première ligne : tenter de mettre tous les prénoms
            const firstLine = text.append("tspan")
                .attr("x", 0)
                .attr("dy", "-0.2em");
            
            const prenomWidth = formattedFirstNames.length * 6;
            if (prenomWidth <= maxWidth) {
                // Les prénoms tiennent sur la première ligne
                firstLine.text(formattedFirstNames);
                // Deuxième ligne : seulement le nom
                text.append("tspan")
                    .attr("x", 0)
                    .attr("dy", "1.2em")
                    .attr("fill", "#0000CD")
                    .text(lastName);
            } else {
                // Les prénoms ne tiennent pas, on les coupe
                const midPoint = Math.floor(prenomWords.length / 2);
                const firstPart = prenomWords.slice(0, midPoint).join(' ');
                const secondPart = prenomWords.slice(midPoint).join(' ');
                
                firstLine.text(firstPart);
                
                // Deuxième ligne : reste des prénoms + nom
                const secondLine = text.append("tspan")
                    .attr("x", 0)
                    .attr("dy", "1.2em");
                
                if (secondPart) {
                    secondLine.text(secondPart + ' ');
                }
                
                text.append("tspan")
                    .attr("fill", "#0000CD")
                    .text(lastName);
            }
        } else {
            text.text(d.data.name);
        }
    });
    

    zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on("zoom", ({transform}) => {
            g.attr("transform", transform);
        });

    svg.call(zoom);
    
    const initialTransform = d3.zoomIdentity
        .translate(boxWidth, height/2)
        .scale(0.8);
    svg.call(zoom.transform, initialTransform);
}

function showTooltip(event, d) {
    const person = d.data;
    let html = `<strong>${person.name}</strong><br>`;
    if (person.birthDate) html += `Naissance: ${person.birthDate}<br>`;
    if (person.deathDate) html += `Décès: ${person.deathDate}<br>`;
    if (person.occupation) html += `Occupation: ${person.occupation}<br>`;
    if (person.marriageDate) html += `Mariage: ${person.marriageDate}`;

    tooltip
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY + 10) + "px")
        .style("opacity", 1)
        .html(html);
}

function hideTooltip() {
    tooltip.style("opacity", 0);
}

function wrapText(text, width) {
    text.each(function() {
        const text = d3.select(this);
        const words = text.text().split(/\s+/);
        const lines = [""];
        let line = 0;
        
        words.forEach(word => {
            const testLine = lines[line] + word + " ";
            if (testLine.length * 6 > width) {
                lines.push(word + " ");
                line++;
            } else {
                lines[line] = testLine;
            }
        });

        text.text(null);
        lines.forEach((l, i) => {
            text.append("tspan")
                .attr("x", 0)
                .attr("dy", i === 0 ? "-0.2em" : "1.2em")
                .text(l.trim());
        });
    });
}

// Gestion du redimensionnement
window.addEventListener('resize', _.debounce(() => {
    const svg = d3.select("#tree-svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);
}, 250));

async function loadData() {
    const password = document.getElementById('password').value;
    try {
        const response = await fetch('arbre.enc');
        const encryptedData = await response.text();
        
        const decoded = atob(encryptedData);
        const key = password.repeat(decoded.length);
        const decrypted = new Uint8Array(decoded.length);
        for(let i = 0; i < decoded.length; i++) {
            decrypted[i] = decoded.charCodeAt(i) ^ key.charCodeAt(i);
        }
        
        const expectedHash = decrypted.slice(0, 8);
        const content = decrypted.slice(8);
        
        const encoder = new TextEncoder();
        const passwordData = encoder.encode(password);
        const hashBuffer = await crypto.subtle.digest('SHA-256', passwordData);
        const actualHash = new Uint8Array(hashBuffer).slice(0, 8);
        
        if (!actualHash.every((val, i) => val === expectedHash[i])) {
            throw new Error('Mot de passe incorrect');
        }
        
        const gedcomContent = pako.inflate(content, {to: 'string'});
        const gedcomData = parseGEDCOM(gedcomContent);
        
        displayPedigree(gedcomData);
        
        document.getElementById('password-form').style.display = 'none';
        document.getElementById('tree-container').style.display = 'block';
    } catch (error) {
        console.error('Erreur:', error);
        alert(error.message);
    }
}
    </script>
</body>
</html>    