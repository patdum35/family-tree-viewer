// ====================================
// Gestionnaire d'export PDF/PNG - VERSION CORRIG√âE
// ====================================
import { state } from './main.js';

/**
 * Exporte l'arbre au format PNG - VERSION CORRIG√âE
 */
export async function exportToPNG(filename = null) {
    try {
        console.log('üì∑ D√©but export PNG...');
        
        const svg = document.querySelector('#tree-svg');
        if (!svg) {
            throw new Error('SVG non trouv√©');
        }

        // V√©rifier qu'il y a du contenu dans le SVG
        const svgContent = svg.innerHTML;
        if (!svgContent || svgContent.trim().length === 0) {
            throw new Error('SVG vide - aucun contenu √† exporter');
        }

        console.log('üìä SVG trouv√©, contenu:', svgContent.length, 'caract√®res');

        // G√©n√©rer le nom de fichier
        const finalFilename = filename || generateFilename('png');
        
        // Cr√©er un canvas avec une meilleure r√©solution
        const canvas = await svgToCanvasFixed(svg, 2); // 2x pour meilleure qualit√©
        
        // T√©l√©charger l'image
        downloadCanvas(canvas, finalFilename);
        
        console.log(`‚úÖ Export PNG r√©ussi: ${finalFilename}`);
        showExportNotification('PNG export√© avec succ√®s!', 'success');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de l\'export PNG:', error);
        showExportNotification('Erreur lors de l\'export PNG: ' + error.message, 'error');
    }
}

/**
 * Exporte l'arbre au format PDF - VERSION CORRIG√âE
 */
export async function exportToPDF(filename = null) {
    try {
        console.log('üìÑ D√©but export PDF...');
        
        // V√©rifier si jsPDF est disponible
        if (typeof window.jsPDF === 'undefined') {
            await loadJsPDF();
        }

        const svg = document.querySelector('#tree-svg');
        if (!svg) {
            throw new Error('SVG non trouv√©');
        }

        // V√©rifier qu'il y a du contenu
        const svgContent = svg.innerHTML;
        if (!svgContent || svgContent.trim().length === 0) {
            throw new Error('SVG vide - aucun contenu √† exporter');
        }

        console.log('üìä SVG trouv√© pour PDF, contenu:', svgContent.length, 'caract√®res');

        // G√©n√©rer le nom de fichier
        const finalFilename = filename || generateFilename('pdf');
        
        // Convertir SVG en canvas
        const canvas = await svgToCanvasFixed(svg, 1.5); // Bonne qualit√© pour PDF
        
        // Cr√©er le PDF
        await createPDFFromCanvas(canvas, finalFilename);
        
        console.log(`‚úÖ Export PDF r√©ussi: ${finalFilename}`);
        showExportNotification('PDF export√© avec succ√®s!', 'success');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de l\'export PDF:', error);
        showExportNotification('Erreur lors de l\'export PDF: ' + error.message, 'error');
    }
}

/**
 * Convertit un SVG en canvas - VERSION CORRIG√âE
 */
export async function svgToCanvasFixed(svgElement, scale = 1) {
    return new Promise((resolve, reject) => {
        try {
            console.log('üîÑ Conversion SVG vers Canvas...');
            
            // Cloner le SVG pour √©viter de modifier l'original
            const clonedSvg = svgElement.cloneNode(true);
            
            // Nettoyer le SVG clon√©
            cleanSVGForExportFixed(clonedSvg);
            
            // Obtenir les dimensions r√©elles du SVG
            const svgRect = svgElement.getBoundingClientRect();
            const svgWidth = svgRect.width || parseInt(svgElement.getAttribute('width')) || 800;
            const svgHeight = svgRect.height || parseInt(svgElement.getAttribute('height')) || 600;
            
            console.log('üìê Dimensions SVG:', svgWidth, 'x', svgHeight);
            
            const canvasWidth = svgWidth * scale;
            const canvasHeight = svgHeight * scale;
            
            // Cr√©er un canvas
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');
            
            // Fond blanc
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Pr√©parer le SVG pour la conversion
            clonedSvg.setAttribute('width', svgWidth);
            clonedSvg.setAttribute('height', svgHeight);
            clonedSvg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            
            // Convertir SVG en string
            const svgString = new XMLSerializer().serializeToString(clonedSvg);
            console.log('üìù SVG s√©rialis√©, longueur:', svgString.length);
            
            // Cr√©er un Blob et une URL
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const svgUrl = URL.createObjectURL(svgBlob);
            
            // Cr√©er une image et la dessiner sur le canvas
            const img = new Image();
            img.onload = function() {
                console.log('üñºÔ∏è Image charg√©e, dessin sur canvas...');
                try {
                    ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                    URL.revokeObjectURL(svgUrl);
                    console.log('‚úÖ Conversion termin√©e');
                    resolve(canvas);
                } catch (drawError) {
                    console.error('‚ùå Erreur lors du dessin:', drawError);
                    URL.revokeObjectURL(svgUrl);
                    reject(drawError);
                }
            };
            
            img.onerror = function(error) {
                console.error('‚ùå Erreur de chargement de l\'image:', error);
                URL.revokeObjectURL(svgUrl);
                reject(new Error('Impossible de charger l\'image SVG'));
            };
            
            // D√©marrer le chargement
            img.src = svgUrl;
            
        } catch (error) {
            console.error('‚ùå Erreur g√©n√©rale dans svgToCanvasFixed:', error);
            reject(error);
        }
    });
}

/**
 * Nettoie le SVG pour l'export - VERSION CORRIG√âE
 */
function cleanSVGForExportFixed(svgElement) {
    console.log('üßπ Nettoyage du SVG pour export...');
    
    // D√©finir les dimensions explicitement
    const rect = svgElement.getBoundingClientRect();
    const width = rect.width || 800;
    const height = rect.height || 600;
    
    svgElement.setAttribute('width', width);
    svgElement.setAttribute('height', height);
    svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
    svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    
    // Assurer que tous les styles sont en ligne
    inlineStylesFixed(svgElement);
    
    // Supprimer les √©l√©ments de contr√¥le interactifs
    removeInteractiveElements(svgElement);
    
    // Nettoyer les filtres et effets
    cleanFiltersAndEffectsFixed(svgElement);
    
    console.log('‚úÖ Nettoyage SVG termin√©');
}

/**
 * Met les styles CSS en ligne dans le SVG - VERSION CORRIG√âE
 */
function inlineStylesFixed(svgElement) {
    const svgElements = svgElement.querySelectorAll('*');
    
    // Styles par d√©faut pour l'√©ventail
    const defaultStyles = {
        '.person-box': {
            'stroke': '#333',
            'stroke-width': '1px'
        },
        '.person-box.root': {
            'fill': '#ff6b6b',
            'stroke': 'white',
            'stroke-width': '4px'
        },
        '.center-person': {
            'fill': '#ff6b6b',
            'stroke': 'white',
            'stroke-width': '4px'
        },
        '.person-box.spouse': {
            'fill': '#98fb98',
            'stroke': '#333',
            'stroke-width': '2px'
        },
        '.person-box.sibling': {
            'fill': '#ffd700',
            'stroke': '#333',
            'stroke-width': '2px'
        },
        '.person-segment': {
            'stroke': 'white',
            'stroke-width': '1.5px'
        },
        '.generation-1': { 'fill': '#e8f4fd' },
        '.generation-2': { 'fill': '#b3d9ff' },
        '.generation-3': { 'fill': '#80bfff' },
        '.generation-4': { 'fill': '#4da6ff' },
        '.generation-5': { 'fill': '#1a8cff' },
        '.generation-6': { 'fill': '#0066cc' },
        'text': {
            'font-family': 'Arial, sans-serif',
            'fill': '#000'
        },
        '.center-text': {
            'fill': 'white',
            'font-weight': 'bold',
            'text-anchor': 'middle'
        },
        '.segment-text': {
            'fill': '#333',
            'text-anchor': 'middle'
        }
    };
    
    // Appliquer les styles par d√©faut
    svgElements.forEach(element => {
        const classList = Array.from(element.classList);
        
        // Appliquer les styles bas√©s sur les classes
        classList.forEach(className => {
            const selector = '.' + className;
            if (defaultStyles[selector]) {
                Object.entries(defaultStyles[selector]).forEach(([prop, value]) => {
                    element.style.setProperty(prop, value);
                });
            }
        });
        
        // Styles calcul√©s importants
        const computedStyle = window.getComputedStyle(element);
        const importantStyles = ['fill', 'stroke', 'stroke-width', 'font-family', 'font-size', 'font-weight', 'text-anchor'];
        importantStyles.forEach(prop => {
            const value = computedStyle.getPropertyValue(prop);
            if (value && value !== 'none' && !element.style.getPropertyValue(prop)) {
                element.style.setProperty(prop, value);
            }
        });
    });
}

/**
 * Supprime les √©l√©ments interactifs du SVG
 */
function removeInteractiveElements(svgElement) {
    // Supprimer les boutons de contr√¥le
    const controlButtons = svgElement.querySelectorAll('.control-button, .expand-button, .collapse-button');
    controlButtons.forEach(button => button.remove());
    
    // Supprimer les √©l√©ments de d√©bug
    const debugElements = svgElement.querySelectorAll('.debug, .helper');
    debugElements.forEach(element => element.remove());
    
    // Nettoyer les √©v√©nements
    const allElements = svgElement.querySelectorAll('*');
    allElements.forEach(element => {
        // Supprimer les attributs d'√©v√©nements
        ['onclick', 'onmouseover', 'onmouseout', 'ondblclick'].forEach(attr => {
            element.removeAttribute(attr);
        });
        
        // Supprimer le curseur pointer
        if (element.style.cursor) {
            element.style.cursor = 'default';
        }
    });
}

/**
 * Nettoie les filtres et effets - VERSION CORRIG√âE
 */
function cleanFiltersAndEffectsFixed(svgElement) {
    // Assurer que les filtres sont bien d√©finis
    let defs = svgElement.querySelector('defs');
    if (!defs) {
        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svgElement.insertBefore(defs, svgElement.firstChild);
    }
    
    // Ajouter le filtre d'ombre si manquant
    if (!defs.querySelector('#drop-shadow')) {
        const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
        filter.setAttribute('id', 'drop-shadow');
        filter.setAttribute('height', '125%');
        filter.setAttribute('width', '125%');
        
        const feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
        feGaussianBlur.setAttribute('in', 'SourceAlpha');
        feGaussianBlur.setAttribute('stdDeviation', '2');
        feGaussianBlur.setAttribute('result', 'blur');
        
        const feOffset = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
        feOffset.setAttribute('in', 'blur');
        feOffset.setAttribute('dx', '2');
        feOffset.setAttribute('dy', '2');
        feOffset.setAttribute('result', 'offsetBlur');
        
        const feComponentTransfer = document.createElementNS('http://www.w3.org/2000/svg', 'feComponentTransfer');
        const feFuncA = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncA');
        feFuncA.setAttribute('type', 'linear');
        feFuncA.setAttribute('slope', '0.5');
        feComponentTransfer.appendChild(feFuncA);
        
        const feMerge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
        const feMergeNode1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
        feMergeNode1.setAttribute('in', 'offsetBlur');
        const feMergeNode2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
        feMergeNode2.setAttribute('in', 'SourceGraphic');
        
        feMerge.appendChild(feMergeNode1);
        feMerge.appendChild(feMergeNode2);
        
        filter.appendChild(feGaussianBlur);
        filter.appendChild(feOffset);
        filter.appendChild(feComponentTransfer);
        filter.appendChild(feMerge);
        
        defs.appendChild(filter);
    }
}

/**
 * T√©l√©charge un canvas comme image
 */
function downloadCanvas(canvas, filename) {
    try {
        const link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL('image/png', 1.0);
        
        // Ajouter au DOM temporairement
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('üì• T√©l√©chargement initi√©:', filename);
    } catch (error) {
        console.error('‚ùå Erreur lors du t√©l√©chargement:', error);
        throw error;
    }
}

/**
 * Cr√©e un PDF √† partir d'un canvas
 */
async function createPDFFromCanvas(canvas, filename) {
    // const { jsPDF } = window;
    const { jsPDF } = window.jspdf;
    // D√©terminer l'orientation selon les dimensions
    const isLandscape = canvas.width > canvas.height;
    const orientation = isLandscape ? 'landscape' : 'portrait';
    
    // Cr√©er le PDF
    const pdf = new jsPDF({
        orientation: orientation,
        unit: 'mm',
        format: 'a4'
    });
    
    // Dimensions de la page A4 en mm
    const pageWidth = orientation === 'landscape' ? 297 : 210;
    const pageHeight = orientation === 'landscape' ? 210 : 297;
    
    // Calculer les dimensions de l'image dans le PDF
    const imgAspectRatio = canvas.width / canvas.height;
    const pageAspectRatio = pageWidth / pageHeight;
    
    let imgWidth, imgHeight;
    if (imgAspectRatio > pageAspectRatio) {
        imgWidth = pageWidth - 20; // Marges de 10mm de chaque c√¥t√©
        imgHeight = imgWidth / imgAspectRatio;
    } else {
        imgHeight = pageHeight - 20; // Marges de 10mm de chaque c√¥t√©
        imgWidth = imgHeight * imgAspectRatio;
    }
    
    // Centrer l'image
    const x = (pageWidth - imgWidth) / 2;
    const y = (pageHeight - imgHeight) / 2;
    
    // Ajouter l'image au PDF
    const imgData = canvas.toDataURL('image/png', 1.0);
    pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
    
    // Ajouter des m√©tadonn√©es
    const rootPersonName = state.currentTree?.name || 'Arbre g√©n√©alogique';
    pdf.setProperties({
        title: `Arbre g√©n√©alogique - ${rootPersonName}`,
        subject: 'Arbre g√©n√©alogique en √©ventail',
        author: 'Application G√©n√©alogie',
        creator: 'Application G√©n√©alogie'
    });
    
    // T√©l√©charger le PDF
    pdf.save(filename);
    console.log('üìÑ PDF g√©n√©r√© et t√©l√©charg√©:', filename);
}

/**
 * Charge la biblioth√®que jsPDF si n√©cessaire
 */
async function loadJsPDF() {
    return new Promise((resolve, reject) => {
        if (typeof window.jsPDF !== 'undefined') {
            resolve();
            return;
        }
        
        console.log('üì¶ Chargement de jsPDF...');
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        script.onload = () => {
            console.log('‚úÖ jsPDF charg√©');
            resolve();
        };
        script.onerror = () => reject(new Error('Impossible de charger jsPDF'));
        document.head.appendChild(script);
    });
}

/**
 * G√©n√®re un nom de fichier automatique
 */
function generateFilename(extension) {
    const date = new Date().toISOString().split('T')[0];
    const rootPersonName = state.currentTree?.name || 'Arbre';
    const mode = state.treeModeReal || 'standard';
    
    // Nettoyer le nom pour le fichier
    const cleanName = rootPersonName
        .replace(/[^a-zA-Z0-9]/g, '_')
        .replace(/_+/g, '_')
        .replace(/^_|_$/g, '');
    
    return `arbre_${cleanName}_${mode}_${date}.${extension}`;
}

/**
 * Affiche une notification d'export
 */
function showExportNotification(message, type = 'info') {
    // Supprimer les notifications existantes
    const existingNotifications = document.querySelectorAll('.export-notification');
    existingNotifications.forEach(notif => notif.remove());
    
    // Cr√©er la notification
    const notification = document.createElement('div');
    notification.className = 'export-notification';
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        border-radius: 5px;
        color: white;
        font-weight: bold;
        z-index: 10000;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        max-width: 300px;
        word-wrap: break-word;
    `;
    
    // Couleur selon le type
    switch (type) {
        case 'success':
            notification.style.backgroundColor = '#28a745';
            break;
        case 'error':
            notification.style.backgroundColor = '#dc3545';
            break;
        default:
            notification.style.backgroundColor = '#007bff';
    }
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Supprimer apr√®s 4 secondes
    setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, 4000);
}

/**
 * Export simple pour test
 */
export async function exportTest() {
    console.log('üß™ Test d\'export...');
    try {
        await exportToPNG('test_export.png');
    } catch (error) {
        console.error('‚ùå √âchec du test d\'export:', error);
    }
}

/**
 * Exporte avec options avanc√©es
 */
export async function exportWithOptions(options = {}) {
    const {
        format = 'png',
        filename = null,
        quality = 1.0,
        scale = 1.0,
        includeBackground = true,
        backgroundColor = 'white'
    } = options;
    
    try {
        const svg = document.querySelector('#tree-svg');
        if (!svg) {
            throw new Error('SVG non trouv√©');
        }
        
        // Cr√©er un canvas avec les options sp√©cifi√©es
        const canvas = await svgToCanvasWithOptions(svg, {
            scale,
            includeBackground,
            backgroundColor
        });
        
        const finalFilename = filename || generateFilename(format);
        
        if (format === 'pdf') {
            await createPDFFromCanvas(canvas, finalFilename);
        } else {
            // PNG ou JPEG
            downloadCanvasWithQuality(canvas, finalFilename, format, quality);
        }
        
        showExportNotification(`Export ${format.toUpperCase()} r√©ussi!`, 'success');
        
    } catch (error) {
        console.error('Erreur lors de l\'export:', error);
        showExportNotification(`Erreur lors de l'export ${format.toUpperCase()}: ${error.message}`, 'error');
    }
}

/**
 * Convertit SVG en canvas avec options avanc√©es
 */
async function svgToCanvasWithOptions(svgElement, options = {}) {
    const {
        scale = 1,
        includeBackground = true,
        backgroundColor = 'white'
    } = options;
    
    return new Promise((resolve, reject) => {
        try {
            const clonedSvg = svgElement.cloneNode(true);
            cleanSVGForExportFixed(clonedSvg);
            
            const svgRect = svgElement.getBoundingClientRect();
            const width = svgRect.width * scale;
            const height = svgRect.height * scale;
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Fond selon les options
            if (includeBackground) {
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, width, height);
            }
            
            const svgData = new XMLSerializer().serializeToString(clonedSvg);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const svgUrl = URL.createObjectURL(svgBlob);
            
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0, width, height);
                URL.revokeObjectURL(svgUrl);
                resolve(canvas);
            };
            img.onerror = function(error) {
                URL.revokeObjectURL(svgUrl);
                reject(error);
            };
            
            img.src = svgUrl;
            
        } catch (error) {
            reject(error);
        }
    });
}

/**
 * T√©l√©charge un canvas avec qualit√© sp√©cifi√©e
 */
function downloadCanvasWithQuality(canvas, filename, format, quality) {
    const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png';
    const link = document.createElement('a');
    link.download = filename;
    link.href = canvas.toDataURL(mimeType, quality);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

/**
 * Exporte seulement la partie visible de l'arbre
 */
export async function exportVisibleArea(format = 'png', filename = null) {
    try {
        const svg = document.querySelector('#tree-svg');
        const mainGroup = svg.querySelector('g');
        
        if (!svg || !mainGroup) {
            throw new Error('√âl√©ments SVG non trouv√©s');
        }
        
        // Pour l'√©ventail, on prend tout le SVG car la zone visible est variable
        const canvas = await svgToCanvasFixed(svg, 1.5);
        const finalFilename = filename || generateFilename(format);
        
        if (format === 'pdf') {
            await createPDFFromCanvas(canvas, finalFilename);
        } else {
            downloadCanvas(canvas, finalFilename);
        }
        
        showExportNotification(`Export de la zone visible r√©ussi!`, 'success');
        
    } catch (error) {
        console.error('Erreur lors de l\'export de la zone visible:', error);
        showExportNotification('Erreur lors de l\'export de la zone visible: ' + error.message, 'error');
    }
}